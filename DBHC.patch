This patches the code release 2023 to run the Dynamic Ball Handling Challenge.
Run `git apply DBHC.patch` in the main directory of the code release.
---
 Config/Behavior/Strategies/dbhc.cfg           |   7 +
 Config/Behavior/Tactics/t012.cfg              |  37 +++
 Config/Robots/Nao/Nao/walkKickEngine.cfg      |   6 +-
 Config/Robots/Nao/Nao/walkingEngine.cfg       |   4 +-
 .../BehaviorControl/passToTeammateImpl.cfg    |  10 -
 .../Default/libLookActiveProvider.cfg         |   1 -
 .../BehaviorControl/passToTeammateImpl.cfg    |  28 ++
 .../BehaviorControl/zweikampfImpl.cfg         |  79 +++++
 .../gameStateProvider.cfg                     |  30 ++
 .../logger.cfg                                | 124 +++++++
 .../selfLocator.cfg                           |  67 ++++
 .../setupPosesProvider.cfg                    |  25 ++
 .../skillBehaviorControl.cfg                  |  17 +
 .../strategyBehaviorControl.cfg               |   1 +
 .../teamMessage.def                           |  92 ++++++
 .../teamMessageHandler.cfg                    |  19 ++
 .../threads.cfg                               | 302 ++++++++++++++++++
 .../walkingEngine.cfg                         |  27 ++
 .../BehaviorControl/passToTeammateImpl.cfg    |  28 ++
 .../behaviorParameters.cfg                    |  25 ++
 .../gameStateProvider.cfg                     |  30 ++
 .../logger.cfg                                | 123 +++++++
 .../selfLocator.cfg                           |  67 ++++
 .../setupPosesProvider.cfg                    |  25 ++
 .../skillBehaviorControl.cfg                  |  18 ++
 .../strategyBehaviorControl.cfg               |   1 +
 .../teamMessage.def                           |  92 ++++++
 .../teamMessageHandler.cfg                    |  19 ++
 .../threads.cfg                               | 302 ++++++++++++++++++
 .../walkingEngine.cfg                         |  27 ++
 .../BehaviorControl/passToTeammateImpl.cfg    |  28 ++
 .../behaviorParameters.cfg                    |  25 ++
 .../gameStateProvider.cfg                     |  30 ++
 .../logger.cfg                                | 123 +++++++
 .../selfLocator.cfg                           |  67 ++++
 .../setupPosesProvider.cfg                    |  25 ++
 .../skillBehaviorControl.cfg                  |  18 ++
 .../strategyBehaviorControl.cfg               |   1 +
 .../teamMessage.def                           |  92 ++++++
 .../teamMessageHandler.cfg                    |  19 ++
 .../threads.cfg                               | 301 +++++++++++++++++
 .../walkingEngine.cfg                         |  27 ++
 Config/Scenes/Drawings/PassToTeammate.con     |   2 +-
 Config/Scenes/Includes/GameStates.con         |   2 +-
 .../DynamicBallHandlingAttacker.con           |  17 +
 .../DynamicBallHandlingAttacker.ros2          |  71 ++++
 .../DynamicBallHandlingAttackerDortmund.con   |  14 +
 .../DynamicBallHandlingAttackerDortmund.ros2  |  71 ++++
 .../DynamicBallHandlingDefender.con           |   6 +
 .../DynamicBallHandlingDefender.ros2          |  71 ++++
 Config/teams.cfg                              |  22 ++
 Src/Libs/SimulatedNao/GameController.cpp      |   6 +-
 Src/Libs/SimulatedNao/GameController.h        |   2 +-
 .../ExecutedPassesProvider.cpp                |  29 ++
 .../ExecutedPassesProvider.h                  |  36 +++
 .../ExpectedGoalsProvider.cpp                 |  62 +++-
 .../ExpectedGoalsProvider.h                   |  33 +-
 .../FieldBallProvider/FieldBallProvider.cpp   |  27 +-
 .../FieldBallProvider/FieldBallProvider.h     |   2 +-
 .../FieldRatingProvider.cpp                   |  17 +-
 .../FieldRatingProvider/FieldRatingProvider.h |   4 +-
 .../Libraries/LibLookActiveProvider.cpp       |  16 +-
 .../Libraries/LibLookActiveProvider.h         |   1 -
 .../PassEvaluationProvider.cpp                |  94 ++++--
 .../PassEvaluationProvider.h                  |  31 +-
 .../Options/HandleCatchBall.h                 |  24 +-
 .../Options/HandleGameState.h                 |  21 +-
 .../SkillBehaviorControl.cpp                  |   7 +-
 .../Skills/Ball/InterceptBall.cpp             |   4 -
 .../Skills/PassToTeammate.cpp                 | 293 ++++++-----------
 .../SkillBehaviorControl/Skills/PlayBall.cpp  |   6 +-
 .../Skills/ReceivePass.cpp                    |   1 +
 .../SkillBehaviorControl/Skills/Zweikampf.cpp |  21 +-
 .../ActiveRoles/PlayBall.cpp                  |  16 +-
 .../ActiveRoles/PlayBall.h                    |  14 +-
 .../PositionRoles/Forward.cpp                 |  33 +-
 .../PositionRoles/Forward.h                   |   2 +
 .../PositionRoles/Midfielder.cpp              |   2 +-
 .../PositionRoles/RatingRole.cpp              |   3 +-
 .../PositionRoles/RatingRole.h                |   2 +
 .../StrategyBehaviorControlDBHDefender.cpp    | 226 +++++++++++++
 .../StrategyBehaviorControlDBHDefender.h      |  79 +++++
 .../StrategyBehaviorControlDBHDortmund.cpp    |  71 ++++
 .../StrategyBehaviorControlDBHDortmund.h      |  44 +++
 .../TeamDataProvider/TeamDataProvider.cpp     |   1 +
 .../TeamMessageHandler/TeamMessageHandler.cpp |   8 +-
 .../TeamMessageHandler/TeamMessageHandler.h   |   2 +
 .../SetupPosesProvider/SetupPosesProvider.cpp |  96 +++++-
 .../SetupPosesProvider/SetupPosesProvider.h   |   2 +
 .../GameStateProvider/GameStateProvider.cpp   |  15 +-
 .../Modeling/SelfLocator/SelfLocator.cpp      |   3 +-
 .../WalkToBallAndKickEngine.cpp               |   3 +
 .../BehaviorControl/BehaviorStatus.h          |   1 +
 .../BehaviorControl/ExecutedPasses.h          |  16 +
 .../BehaviorControl/FieldRating.h             |   2 +-
 .../BehaviorControl/PassEvaluation.h          |   2 +-
 .../Communication/ReceivedTeamMessages.h      |   2 +
 .../Communication/SentTeamMessage.h           |   2 +
 Src/Representations/Communication/TeamData.h  |   2 +
 .../Modeling/ObstacleModel.cpp                |  15 +
 Src/Representations/Modeling/ObstacleModel.h  |   9 +-
 .../MotionControl/MotionRequest.cpp           |  14 +-
 Src/Tools/BehaviorControl/KickSelection.h     |   2 +-
 .../BehaviorControl/Strategy/BehaviorBase.h   |   2 +
 Src/Tools/BehaviorControl/Strategy/Strategy.h |   1 +
 Src/Tools/BehaviorControl/Strategy/Tactic.h   |   1 +
 Src/Tools/Motion/KickPrecision.h              |   1 +
 107 files changed, 3730 insertions(+), 366 deletions(-)
 create mode 100644 Config/Behavior/Strategies/dbhc.cfg
 create mode 100644 Config/Behavior/Tactics/t012.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/BehaviorControl/passToTeammateImpl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/BehaviorControl/zweikampfImpl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/gameStateProvider.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/logger.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/selfLocator.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/setupPosesProvider.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/skillBehaviorControl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/strategyBehaviorControl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/teamMessage.def
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/teamMessageHandler.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/threads.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeAttacker/walkingEngine.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/BehaviorControl/passToTeammateImpl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/behaviorParameters.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/gameStateProvider.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/logger.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/selfLocator.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/setupPosesProvider.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/skillBehaviorControl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/strategyBehaviorControl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/teamMessage.def
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/teamMessageHandler.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/threads.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDefender/walkingEngine.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/BehaviorControl/passToTeammateImpl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/behaviorParameters.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/gameStateProvider.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/logger.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/selfLocator.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/setupPosesProvider.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/skillBehaviorControl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/strategyBehaviorControl.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/teamMessage.def
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/teamMessageHandler.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/threads.cfg
 create mode 100644 Config/Scenarios/DynamicBallHandlingChallengeDortmund/walkingEngine.cfg
 create mode 100644 Config/Scenes/OtherScenes/DynamicBallHandlingAttacker.con
 create mode 100644 Config/Scenes/OtherScenes/DynamicBallHandlingAttacker.ros2
 create mode 100644 Config/Scenes/OtherScenes/DynamicBallHandlingAttackerDortmund.con
 create mode 100644 Config/Scenes/OtherScenes/DynamicBallHandlingAttackerDortmund.ros2
 create mode 100644 Config/Scenes/OtherScenes/DynamicBallHandlingDefender.con
 create mode 100644 Config/Scenes/OtherScenes/DynamicBallHandlingDefender.ros2
 create mode 100644 Src/Modules/BehaviorControl/ExecutedPassesProvider/ExecutedPassesProvider.cpp
 create mode 100644 Src/Modules/BehaviorControl/ExecutedPassesProvider/ExecutedPassesProvider.h
 create mode 100644 Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDefender.cpp
 create mode 100644 Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDefender.h
 create mode 100644 Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDortmund.cpp
 create mode 100644 Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDortmund.h
 create mode 100644 Src/Representations/BehaviorControl/ExecutedPasses.h

diff --git a/Config/Behavior/Strategies/dbhc.cfg b/Config/Behavior/Strategies/dbhc.cfg
new file mode 100644
index 0000000000..6eb4698bb7
--- /dev/null
+++ b/Config/Behavior/Strategies/dbhc.cfg
@@ -0,0 +1,7 @@
+tactics = [
+  {
+    tactic = t012;
+    transitions = [
+    ];
+  },
+];
diff --git a/Config/Behavior/Tactics/t012.cfg b/Config/Behavior/Tactics/t012.cfg
new file mode 100644
index 0000000000..abb7383f5b
--- /dev/null
+++ b/Config/Behavior/Tactics/t012.cfg
@@ -0,0 +1,37 @@
+positions = [
+  {
+    type = midfielderR;
+    pose = {
+      rotation = 0deg;
+      translation = {x = xPosOwnGoalArea * 0.5; y = 0;};
+    };
+  },
+  {
+    type = forwardL;
+    pose = {
+      rotation = 0deg;
+      translation = {x = xPosOpponentPenaltyArea * 0.5; y = yPosLeftGoalArea * 1.5;};
+    };
+  },
+  {
+    type = forwardR;
+    pose = {
+      rotation = 0deg;
+      translation = {x = xPosOpponentPenaltyArea * 0.5; y = yPosRightGoalArea * 1.5;};
+    };
+  }
+];
+priorityGroups = [
+  {
+    positions = [midfielderR];
+    priorities = [1];
+  },
+  {
+    positions = [forwardL];
+    priorities = [2];
+  },
+  {
+    positions = [forwardR];
+    priorities = [3];
+  }
+];
diff --git a/Config/Robots/Nao/Nao/walkKickEngine.cfg b/Config/Robots/Nao/Nao/walkKickEngine.cfg
index 3bd57d51c8..e7e0a2d2f2 100644
--- a/Config/Robots/Nao/Nao/walkKickEngine.cfg
+++ b/Config/Robots/Nao/Nao/walkKickEngine.cfg
@@ -1174,9 +1174,9 @@ walkKicksList = {
         jointOffsets = [
           {
             joint = lHipPitch;
-            offset = -10deg;
-            minRatio = 0.35;
-            middleRatio = 0.65;
+            offset = -14deg;
+            minRatio = 0.25;
+            middleRatio = 0.85;
             maxRatio = 1;
             minimumRatio = 0.25;
             shiftByKeyFrame = -1;
diff --git a/Config/Robots/Nao/Nao/walkingEngine.cfg b/Config/Robots/Nao/Nao/walkingEngine.cfg
index fa0a739992..434da93d3d 100644
--- a/Config/Robots/Nao/Nao/walkingEngine.cfg
+++ b/Config/Robots/Nao/Nao/walkingEngine.cfg
@@ -1,11 +1,11 @@
 configuratedParameters = {
   maxSpeed = {
     rotation = 120deg;
-    translation = {x = 300; y = 230;};
+    translation = {x = 270; y = 200;};
   };
   minSpeed = {
     rotation = 120deg;
-    translation = {x = 300; y = 230;};
+    translation = {x = 270; y = 200;};
   };
   maxSpeedBackwards = 150;
   minSpeedBackwards = 125;
diff --git a/Config/Scenarios/Default/BehaviorControl/passToTeammateImpl.cfg b/Config/Scenarios/Default/BehaviorControl/passToTeammateImpl.cfg
index 2aab4f8c6c..e38f70ac4c 100644
--- a/Config/Scenarios/Default/BehaviorControl/passToTeammateImpl.cfg
+++ b/Config/Scenarios/Default/BehaviorControl/passToTeammateImpl.cfg
@@ -11,20 +11,14 @@ allowedKicks = [
   walkForwardsLeftAlternative
 ];
 doSpecialKickChecks = true;
-minKickLengthForLong = 4500;
 ratingThreshold = 0.7;
 passAheadDistance = 0;
 minAngleOffset = 7deg;
 maxAngleOffset = 25deg;
 maxAngleOffsetBehind = 10deg;
 maxPrecisionOffset = 5deg;
-waitingPositionOffset = {x = -150; y = 0;};
 targetOffsetToFieldBorder = 800;
-timeLeftToAdjust = 7000;
-minTimeWaiting = 3000;
-maxTimeWaiting = 8000;
 maxTimeWaitingFactor = 0.1;
-kickRangeOffset = 500;
 averageKickExecutionTime = 800;
 averageKickBallOffset = {x = -185; y = 0;};
 ignoreObstaclesThreshold = 250;
@@ -34,7 +28,3 @@ maxLookAheadTime = 3000;
 interceptionDistanceThreshold = {min = 100; max = 400;};
 targetDistanceScale = {min = 0; max = 4000;};
 minRating = 0.01;
-
-maxHeadAngle = 60deg;
-headSpeed = 60deg;
-headTilt = 15deg;
diff --git a/Config/Scenarios/Default/libLookActiveProvider.cfg b/Config/Scenarios/Default/libLookActiveProvider.cfg
index ea5cc00a25..5aa8b46e6d 100644
--- a/Config/Scenarios/Default/libLookActiveProvider.cfg
+++ b/Config/Scenarios/Default/libLookActiveProvider.cfg
@@ -16,4 +16,3 @@ lookAtCloseObstacleWhenFollowingBall = true;
 maxObstacleDistanceToBeLookedAt = 1000;
 maxObstacleAgeToBeLookedAt = 1000;
 cameraChoiceHysteresis = 2deg;
-teammatesBallModelError = 500;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/BehaviorControl/passToTeammateImpl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/BehaviorControl/passToTeammateImpl.cfg
new file mode 100644
index 0000000000..24b0dabd4f
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/BehaviorControl/passToTeammateImpl.cfg
@@ -0,0 +1,28 @@
+allowedKicks = [
+  forwardFastRightPass,
+  forwardFastLeftPass,
+  walkForwardsRightLong,
+  walkForwardsLeftLong
+];
+doSpecialKickChecks = true;
+ratingThreshold = 0.7;
+passAheadDistance = 0;
+passTargetDistanceMinimum = 1600;
+minAngleOffset = 15deg;
+maxAngleOffset = 40deg;
+maxAngleOffsetBehind = 20deg;
+maxPrecisionOffset = 5deg;
+targetOffsetToFieldBorder = 800;
+maxTimeWaitingFactor = 0.1;
+averageKickExecutionTime = 800;
+averageKickBallOffset = {x = -185; y = 0;};
+ignoreObstaclesThreshold = 250;
+ignoreDynamicObstaclesThreshold = 500;
+standKickObstacleDistanceTreshold = 1000;
+lookAhead = true;
+maxLookAheadTime = 5000;
+interceptionDistanceThreshold = {min = 100; max = 400;};
+targetDistanceScale = {min = 0; max = 4000;};
+minRating = 0.01;
+rotationThresholdNear = 100deg;
+translationThresholdNear = 150;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/BehaviorControl/zweikampfImpl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/BehaviorControl/zweikampfImpl.cfg
new file mode 100644
index 0000000000..4c8ef8b298
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/BehaviorControl/zweikampfImpl.cfg
@@ -0,0 +1,79 @@
+searchParameters = {
+  numOfAnglesNearBestDuelPose = 3;
+  rangeOfBestDuelPose = 10deg;
+  numOfOverallSearch = 5;
+  overallSearchRange = 180deg;
+  bonusForStealBallDirectionAdjustmentSmall = 0.01deg;
+  bonusForStealBallDirectionAdjustmentBig = 3deg;
+  moreSearchAfterDoingNothing = 50;
+  goalSectorWidth = 1deg;
+  minMaxAngleAngleRange = {min = 90deg; max = 100deg;};
+};
+duelRatings = {
+  ratingMinMaxDifference = 0.3;
+  ratingBallLandsInOwnHalf = 0.2;
+  ratingPoseBlockedSmallKickAngle = 0.3;
+  ratingPoseBlocked = 1;
+  ratingOpponentFaster = 0.1;
+  ratingSameKick = -0.1;
+  ratingSameKickAngle = -0.1;
+  ratingStealBall = -0.4;
+  goalAreaLongKickRating = -0.5;
+  ratingStealBallKick = -0.9;
+  ratingStealBallKickBetterSide = -0.05;
+  ratingGoalShot = -1.5;
+};
+duelTimings = {
+  maxTimeDoingNothing = 1000;
+  deactiveAfterDoingNothing = 5000;
+  sidewardRestrictionTime = 4000;
+  noKickMinTime = 200;
+  noKickStealMinTime = 250;
+  ignoreSkillRequestTime = 2000;
+};
+obstacleHandling = {
+  leftFootEdge = {x = 110; y = 100;};
+  rightFootEdge = {x = 110; y = -100;};
+  leftFootKickEdge = {x = 170; y = 100;};
+  rightFootKickEdge = {x = 170; y = -100;};
+  maxObstacleDistanceForWalkStealBallKick = 100;
+  maxObstacleDistanceForSideStealBallKick = 450;
+  obstacleDistanceForBlockingPose = 100;
+  obstacleBlockingRadius = 200;
+  obstacleBlockingRadiusSidewardsIncrease = 30;
+  noKickBlockingPose = 180;
+  obstacleMinDistanceForBackPass = 600;
+  obstacleShiftRange = {min = -100; max = 30;};
+  maxObstacleDistanceToBallForRiskyKicks = 600;
+  maxObstacleDistanceToForceForwardSteal = 200;
+};
+stealBallParameters = {
+  stealBallTypeTooMuchRotationMinValue = 25deg;
+  bonusForStealBallMinMaxAngle = 120deg;
+  stealBallRange = {min = 88deg; max = 95deg;};
+  stealBallMinRobotRotation = 70deg;
+  stealBallMinPositionRotation = 45deg;
+  forwardStealBallOpponentPositionNormal = {min = 50deg; max = 70deg;};
+  forwardStealBallOpponentPositionMalus = 40deg;
+};
+lastKickHysterese = {
+  kickLengthHysterese = 500;
+  kickDirectionHysterese = 20deg;
+};
+smallerKickAnglePreference = 15deg;
+forwardStealPreferenceRange = 10deg;
+replaceNormalToLongKickGoalShot = 10deg;
+sectorWheelObstacleBallRadiusFactor = 6;
+allowPassAngle = {min = -45deg; max = 45deg;};
+fieldBorderSafeDistance = 1000;
+minForwardTurnRange = 1000;
+sidewardsRotationCorrectionBonus = 5deg;
+ballPositionInterpolationRange = { min = 250; max = 500; };
+lookActiveMinBallDistance = 500;
+replaceForwardWithLongGoalShot = true;
+allowedKicks = [
+  walkForwardsLeftLong,
+  walkForwardsRightLong,
+  walkForwardsRightAlternative,
+  walkForwardsLeftAlternative,
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/gameStateProvider.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/gameStateProvider.cfg
new file mode 100644
index 0000000000..131dbd7455
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/gameStateProvider.cfg
@@ -0,0 +1,30 @@
+unstiffHeadButtonPressDuration = 1000; // [ms]
+calibrationHeadButtonPressDuration = 200; // [ms]
+unstiffAfterHalfDuration = 7777; // [ms]
+gameControllerTimeout = 2000; // [ms]
+ballSaveInterval = 100; // [ms]
+ballHasMovedTolerance = 100; // [mm]
+ballHasMovedCloseToRobotThreshold = 300; // [mm]
+ballOutOfCenterCircleCounterThreshold = 10;
+ballOutOfCenterCircleTolerance = 200; // [mm]
+maxWhistleTimeDifference = 1000; // [ms]
+minVotersForWhistle = 3;
+minWhistleAverageConfidence = 1.15;
+ignoreWhistleAfterKickOff = 5000; // [ms]
+ignoreWhistleAfterPenaltyKick = 2000; // [ms]
+checkWhistleForGoal = false;
+checkBallForGoal = false;
+gameControllerOperatorDelay = 3000; // [ms]
+acceptBallInGoalDelay = 5000; // [ms]
+acceptPastWhistleDelay = 3000; // [ms]
+confidenceIntervalToLegalPositionFree = 0.99; // [no unit]
+confidenceIntervalToLegalPositionNotFree = 0.999; // [no unit]
+ballPlacementTolerance = 50; // [mm]
+
+kickOffSetupDuration = 45000; // [ms]
+kickOffDuration = 10000; // [ms]
+penaltyKickSetupDuration = 30000; // [ms]
+penaltyKickDuration = 30000; // [ms]
+freeKickDuration = 30000; // [ms]
+playingSignalDelay = 15000; // [ms]
+goalSignalDelay = 15000; // [ms]
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/logger.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/logger.cfg
new file mode 100644
index 0000000000..c6e56c9175
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/logger.cfg
@@ -0,0 +1,124 @@
+// Is logging enabled?
+enabled = true;
+
+// The directory that will contain the log file.
+path = "/home/nao/logging";
+
+// The number of buffers allocated.
+numOfBuffers = 12000;
+
+// The size of each buffer in bytes.
+sizeOfBuffer = 200000;
+
+// The scheduling priority of the writer thread.
+writePriority = -2;
+
+// Logging will stop if less MB are available to the target device.
+minFreeDriveSpace = 100;
+
+// Representations to log per thread
+representationsPerThread = [
+  {
+    thread = Upper;
+    representations = [
+      JPEGImage,
+
+      BallPercept,
+      BallSpots,
+      BodyContour,
+      CameraInfo,
+      CameraMatrix,
+      CirclePercept,
+      FieldBoundary,
+      FrameInfo,
+      ImageCoordinateSystem,
+      LinesPercept,
+      ObstaclesFieldPercept,
+      ObstaclesImagePercept,
+      OdometryData,
+      PenaltyMarkPercept,
+    ];
+  },
+  {
+    thread = Lower;
+    representations = [
+      JPEGImage,
+
+      BallPercept,
+      BallSpots,
+      BodyContour,
+      CameraInfo,
+      CameraMatrix,
+      CirclePercept,
+      FieldBoundary,
+      FrameInfo,
+      ImageCoordinateSystem,
+      LinesPercept,
+      ObstaclesFieldPercept,
+      ObstaclesImagePercept,
+      OdometryData,
+      PenaltyMarkPercept,
+    ];
+  },
+  {
+    thread = Cognition;
+    representations = [
+      ActivationGraph,
+      AlternativeRobotPoseHypothesis,
+      ArmMotionRequest,
+      BallModel,
+      BehaviorStatus,
+      CameraCalibration,
+      GameState,
+      IMUCalibration,
+      MotionRequest,
+      ObstacleModel,
+      OdometryData,
+      ReceivedTeamMessages,
+      RobotHealth,
+      RobotPose,
+      SelfLocalizationHypotheses,
+      SideInformation,
+      SkillRequest,
+      StrategyStatus,
+      TeammatesBallModel,
+      TeamData,
+    ];
+  },
+  {
+    thread = Motion;
+    representations = [
+      FallDownState,
+      FootOffset,
+      FootSupport,
+      FrameInfo,
+      FsrData,
+      FsrSensorData,
+      GroundContactState,
+      GyroState,
+      InertialSensorData,
+      InertialData,
+      JointAnglePred,
+      JointCalibration,
+      JointPlay,
+      JointRequest,
+      JointSensorData,
+      KeyStates,
+      MotionInfo,
+      OdometryData,
+      OdometryDataPreview,
+      SystemSensorData,
+      RobotStableState,
+      WalkLearner,
+      WalkStepData,
+    ];
+  },
+  {
+    thread = Audio;
+    representations = [
+      AudioData,
+      FrameInfo,
+      Whistle,
+    ];
+  }
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/selfLocator.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/selfLocator.cfg
new file mode 100644
index 0000000000..56c23c21a1
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/selfLocator.cfg
@@ -0,0 +1,67 @@
+numberOfSamples = 12;
+
+defaultPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 500; y = 500;};
+    };
+walkInPoseDeviation = {
+      rotation = 12deg;
+      translation = {x = 500; y = 1000;};
+    };
+returnFromPenaltyPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 700; y = 200;};
+    };
+manualPlacementPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 500; y = 500;};
+    };
+penaltyShootoutPoseDeviation = {
+      rotation = 9deg;
+      translation = {x = 200; y = 200;};
+    };
+filterProcessDeviation = {
+      rotation = 0.002;
+      translation = {x = 2.0; y = 2.0;};
+    };
+odometryDeviation  = {
+      rotation = 0.3;
+      translation = {x = 0.2; y = 0.2;};
+    };
+odometryRotationDeviation  = {
+      x = 0.00157;
+      y = 0.00157;
+    };
+
+movedDistWeightRotationNoise = 0.0005;
+movedAngleWeightRotationNoise = 0.25;
+movedAngleWeightRotationNoiseNotWalking = 0.075;
+majorDirTransWeight = 2;
+minorDirTransWeight = 1;
+
+minValidityForSuperbLocalizationQuality = 0.8;
+maxTranslationDeviationForSuperbLocalizationQuality = 100.0;
+maxRotationalDeviationForSuperbLocalizationQuality = 10deg;
+baseValidityWeighting = 0.1;
+numberOfConsideredFramesForValidity  = 60;
+considerLinesForValidityComputation = true;
+validityFactorPoseMeasurement = 5;
+validityFactorLandmarkMeasurement = 3;
+validityFactorLineMeasurement = 1;
+
+positionJumpNotificationDistance = 2000.0;
+
+minNumberOfObservationsForResetting = 6;
+translationalDeviationForResetting = 1500.0;
+rotationalDeviationForResetting = 0.5;
+returnFromPenaltyMaxXOffset = 250.0;
+
+demoUseCustomReturnFromPenaltyPoses = false;
+demoCustomReturnFromPenaltyPoseGoalie = {
+      rotation = 0deg;
+      translation = {x = -2000.0; y = 0.0;};
+    };
+demoCustomReturnFromPenaltyPoseFieldPlayer = {
+      rotation = 0deg;
+      translation = {x = -750.0; y = 0.0;};
+    };
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/setupPosesProvider.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/setupPosesProvider.cfg
new file mode 100644
index 0000000000..d5575b3573
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/setupPosesProvider.cfg
@@ -0,0 +1,25 @@
+// Positions as defined in the latest version of the rule book:
+// ATTACKERS ONLY:
+// - 1st: goal area front line;
+// - 2nd: near halfway line left of center circle;
+// - 3rd: near halfway line right of center circle;
+poses = [
+  // Note: The SetupPosesProvider will randomize these setup positions within the player's corresponding area as defined in the challenge rules.
+  {
+    playerNumber = 1;                     /*< The player number of the robot */
+    position = {x = -3900; y = 0;};       /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = 0;};      /*< The position (in global field coordinates) at which the robot is turned */
+  },
+  {
+    playerNumber = 2;                     /*< The player number of the robot */
+    position = {x = -485; y = 2235;};       /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = 2235;};      /*< The position (in global field coordinates) at which the robot is turned */
+  },
+  {
+    playerNumber = 3;                     /*< The player number of the robot */
+    position = {x = -485; y = -2235;};           /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = -2235;};   /*< The position (in global field coordinates) at which the robot is turned */
+  },
+ // Other player numbers are not defined here. In case a robot is deployed with number 4 - 7,
+ // an assert will terminate the software :-)
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/skillBehaviorControl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/skillBehaviorControl.cfg
new file mode 100644
index 0000000000..c50a505a97
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/skillBehaviorControl.cfg
@@ -0,0 +1,17 @@
+options = [
+  HandlePhysicalRobot,
+  HandlePlayerState,
+  HandleGameState,
+];
+
+playingOptions = [
+  HandleStrikerLostBall,
+  HandleCatchBall2023,
+];
+
+useNewHandleCatchBallBehavior = true;
+
+// Referee Challenge options
+refereeXRange = {min = -1000; max = 800;};
+refereeYRange = {min = 0; max = 1900;};
+refereeDuration = 10000;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/strategyBehaviorControl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/strategyBehaviorControl.cfg
new file mode 100644
index 0000000000..47db364ce4
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/strategyBehaviorControl.cfg
@@ -0,0 +1 @@
+strategy = dbhc;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/teamMessage.def b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/teamMessage.def
new file mode 100644
index 0000000000..e7f04b30c0
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/teamMessage.def
@@ -0,0 +1,92 @@
+RobotPoseCompact
+{
+  rotation: Angle(bits=8)
+  translation: Vector<Float(min=-5120, max=5110, bits=10)>(n=2)
+  quality: Enum(type=RobotPose::LocalizationQuality)
+  covariance: Matrix<Integer(min=-32768, max=32767)>(m=2, n=2, symmetric) // Is actually something like Matrix<float16_t>
+  timestampLastJump: Timestamp(bits=1, shift=10, reference=relativePast, noclip)
+}
+
+RobotStatus
+{
+  isUpright: Boolean
+  timeWhenLastUpright: Timestamp(bits=8, shift=6, reference=relativePast)
+}
+
+BallState
+{
+  position: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)
+  velocity: Vector<Float(min=-8000, max=8000, bits=11)>(n=2)
+  // covariance: Matrix<Float>(m=2, n=2, symmetric) // Unused
+}
+
+BallModel
+{
+  // lastPerception: Vector<Float(min=-32768, max=32767, bits=16)>(n=2) // Unused
+  estimate: BallState
+  timeWhenDisappeared: Timestamp(bits=9, shift=6, reference=relativePast, noclip)
+  timeWhenLastSeen: Timestamp(bits=11, shift=4, reference=relativePast, noclip)
+  // seenPercentage: Integer(min=0, max=100) // Unused
+}
+
+RecentWhistle
+{
+  confidenceOfLastWhistleDetection: Float(min=0, max=2.55, bits=8)
+  lastTimeWhistleDetected: Timestamp(bits=8, shift=4, reference=relativePast, noclip)
+}
+
+WhistleCompact
+{
+  listening: Boolean
+  recentWhistle: RecentWhistle[:1]
+}
+
+BehaviorStatus
+{
+  passTarget: Integer(min=-1, max=14)
+  walkingTo: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)
+  speed: Float(min=0.0, max=310.0, bits=5)
+  shootingTo: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)[:1]
+  lastKickTimestamp: Timestamp
+}
+
+StrategyStatus
+{
+  proposedTactic: Enum(type=Tactic::Type)
+  acceptedTactic: Enum(type=Tactic::Type)
+  proposedMirror: Boolean
+  acceptedMirror: Boolean
+  proposedSetPlay: Enum(type=SetPlay::Type)
+  acceptedSetPlay: Enum(type=SetPlay::Type)
+  position: Enum(type=Tactic::Position::Type)
+  role: Enum(type=Role::Type)
+}
+
+Obstacle
+{
+  center: Vector<Float(min=-32768, max=32767, bits=16)>(n=2)
+  lastSeen: Timestamp(bits=8, shift=6, reference=relativePast)
+  type: Enum(type=Obstacle::Type)
+}
+
+ObstacleModel
+{
+  obstacles: Obstacle[:3]
+}
+
+FrameInfo
+{
+  time: Timestamp(bits=0, reference=relativePast)
+}
+
+TeamMessage
+{
+  theRobotPose: RobotPoseCompact
+  theRobotStatus: RobotStatus
+  theFrameInfo: FrameInfo
+  theBallModel: BallModel
+  theWhistle: WhistleCompact
+  theBehaviorStatus: BehaviorStatus
+  theStrategyStatus: StrategyStatus
+  theObstacleModel: ObstacleModel
+}
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/teamMessageHandler.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/teamMessageHandler.cfg
new file mode 100644
index 0000000000..77aedcc8b2
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/teamMessageHandler.cfg
@@ -0,0 +1,19 @@
+minSendInterval = 650;
+durationOfHalf = 240000;
+overallMessageBudget = 1200;
+normalMessageReserve = 20;
+priorityMessageReserve = 10;
+lookahead = 5000;
+positionThreshold = 200;
+bearingThreshold = 3deg;
+assumedObservationHeight = 450;
+teamBallThresholdBase = 9000;
+teamBallThresholdFactor = 500;
+newBallThreshold = 500;
+disappearedThreshold = 3000;
+ignoreWhistleBeforeEndOfHalf = 5000;
+maxWhistleSendDelay = 4000;
+minTimeBetween2RejectSounds = 5000;
+sendMirroredRobotPose = false;
+dropUnsynchronizedMessages = true;
+alwaysSend = true;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/threads.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/threads.cfg
new file mode 100644
index 0000000000..df97b67255
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/threads.cfg
@@ -0,0 +1,302 @@
+defaultRepresentations = [
+  CalibrationGenerator,
+  GroundTruthRobotPose,
+  RefereePercept,
+  ReplayWalkRequestGenerator,
+];
+threads = [
+  {
+    name = Upper;
+    priority = 0;
+    debugReceiverSize = 2800000;
+    debugSenderSize = 5200000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Perception;
+    representationProviders = [
+      {representation = OtherFieldBoundary; provider = LowerProvider;},
+      {representation = OtherObstaclesPerceptorData; provider = LowerProvider;},
+      {representation = OtherOdometryData; provider = LowerProvider;},
+
+      {representation = AutoExposureWeightTable; provider = AutoExposureWeightTableProvider;},
+      {representation = BallPercept; provider = BallPerceptor;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BallSpots; provider = BallSpotsProvider;},
+      {representation = BodyContour; provider = BodyContourProvider;},
+      {representation = CameraImage; provider = CameraProvider;},
+      {representation = CameraInfo; provider = CameraProvider;},
+      {representation = CameraIntrinsics; provider = CameraProvider;},
+      {representation = CameraMatrix; provider = CameraMatrixProvider;},
+      {representation = CameraSettings; provider = ConfigurationDataProvider;},
+      {representation = CameraStatus; provider = CameraProvider;},
+      {representation = CirclePercept; provider = LinePerceptor;},
+      {representation = ColorScanLineRegionsHorizontal; provider = ScanLineRegionizer;},
+      {representation = ColorScanLineRegionsVerticalClipped; provider = ScanLineRegionizer;},
+      {representation = ECImage; provider = ECImageProvider;},
+      {representation = FieldBoundary; provider = FieldBoundaryProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldLineIntersections; provider = FieldLinesProvider;},
+      {representation = FieldLines; provider = FieldLinesProvider;},
+      {representation = FrameInfo; provider = CameraProvider;},
+      {representation = ImageCoordinateSystem; provider = CoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = IntersectionsProvider;},
+      {representation = JerseyClassifier; provider = JerseyClassifierProvider2020For2023;},
+      {representation = JPEGImage; provider = CameraProvider;},
+      {representation = LinesPercept; provider = LinePerceptor;},
+      {representation = MeasurementCovariance; provider = LegacyMeasurementCovarianceProvider;},
+      {representation = ObstaclesFieldPercept; provider = RobotDetector;},
+      {representation = ObstaclesImagePercept; provider = RobotDetector;},
+      {representation = ObstaclesPerceptorData; provider = RobotDetector;},
+      {representation = OdometryData; provider = ImageFrameProvider;},
+      {representation = OptionalECImage; provider = ECImageProvider;},
+      {representation = OptionalCameraImage; provider = OptionalCameraImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PenaltyMarkPerceptor;},
+      {representation = PenaltyMarkRegions; provider = PenaltyMarkRegionsProvider;},
+      {representation = RelativeFieldColors; provider = RelativeFieldColorsProvider;},
+      {representation = RelativeFieldColorsParameters; provider = ConfigurationDataProvider;},
+      {representation = RobotCameraMatrix; provider = RobotCameraMatrixProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = ScanGrid; provider = ScanGridProvider;},
+    ];
+  }, {
+    name = Lower;
+    priority = 0;
+    debugReceiverSize = 1000000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Perception;
+    representationProviders = [
+      {representation = OtherFieldBoundary; provider = UpperProvider;},
+      {representation = OtherObstaclesPerceptorData; provider = UpperProvider;},
+      {representation = OtherOdometryData; provider = UpperProvider;},
+
+      {representation = AutoExposureWeightTable; provider = AutoExposureWeightTableProvider;},
+      {representation = BallPercept; provider = BallPerceptor;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BallSpots; provider = BOPPerceptor;},
+      {representation = BodyContour; provider = BodyContourProvider;},
+      {representation = CameraImage; provider = CameraProvider;},
+      {representation = CameraInfo; provider = CameraProvider;},
+      {representation = CameraIntrinsics; provider = CameraProvider;},
+      {representation = CameraMatrix; provider = CameraMatrixProvider;},
+      {representation = CameraSettings; provider = ConfigurationDataProvider;},
+      {representation = CameraStatus; provider = CameraProvider;},
+      {representation = CirclePercept; provider = LinePerceptor;},
+      {representation = ColorScanLineRegionsHorizontal; provider = ScanLineRegionizer;},
+      {representation = ColorScanLineRegionsVerticalClipped; provider = ScanLineRegionizer;},
+      {representation = ECImage; provider = ECImageProvider;},
+      {representation = FieldBoundary; provider = FieldBoundaryProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldLineIntersections; provider = FieldLinesProvider;},
+      {representation = FieldLines; provider = FieldLinesProvider;},
+      {representation = FrameInfo; provider = CameraProvider;},
+      {representation = ImageCoordinateSystem; provider = CoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = IntersectionsProvider;},
+      {representation = JerseyClassifier; provider = JerseyClassifierProvider2020For2023;},
+      {representation = JPEGImage; provider = CameraProvider;},
+      {representation = LinesPercept; provider = LinePerceptor;},
+      {representation = MeasurementCovariance; provider = LegacyMeasurementCovarianceProvider;},
+      {representation = ObstaclesFieldPercept; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = ObstaclesImagePercept; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = ObstaclesPerceptorData; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = OdometryData; provider = ImageFrameProvider;},
+      {representation = OptionalECImage; provider = ECImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PenaltyMarkPerceptor;},
+      {representation = PenaltyMarkRegions; provider = BOPPerceptor;},
+      {representation = RelativeFieldColors; provider = RelativeFieldColorsProvider;},
+      {representation = RelativeFieldColorsParameters; provider = ConfigurationDataProvider;},
+      {representation = RobotCameraMatrix; provider = RobotCameraMatrixProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = ScanGrid; provider = ScanGridProvider;},
+      {representation = SegmentedObstacleImage; provider = BOPPerceptor;},
+    ];
+  }, {
+    name = Cognition;
+    priority = 1;
+    debugReceiverSize = 2000000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 200000;
+    executionUnit = Cognition;
+    representationProviders = [
+      {representation = BallPercept; provider = PerceptionBallPerceptProvider;},
+      {representation = BodyContour; provider = PerceptionBodyContourProvider;},
+      {representation = CameraInfo; provider = PerceptionCameraInfoProvider;},
+      {representation = CameraMatrix; provider = PerceptionCameraMatrixProvider;},
+      {representation = CameraStatus; provider = PerceptionCameraStatusProvider;},
+      {representation = CenterCircleWithLine; provider = CenterCircleWithLinePerceptor;},
+      {representation = CirclePercept; provider = PerceptionCirclePerceptProvider;},
+      {representation = FieldBoundary; provider = PerceptionFieldBoundaryProvider;},
+      {representation = FieldLines; provider = PerceptionFieldLinesProvider;},
+      {representation = FieldLineIntersections; provider = PerceptionFieldLineIntersectionsProvider;},
+      {representation = FrameInfo; provider = PerceptionFrameInfoProvider;},
+      {representation = ImageCoordinateSystem; provider = PerceptionImageCoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = PerceptionIntersectionsPerceptProvider;},
+      {representation = LinesPercept; provider = PerceptionLinesPerceptProvider;},
+      {representation = ObstaclesFieldPercept; provider = PerceptionObstaclesFieldPerceptProvider;},
+      {representation = OdometryData; provider = MotionProvider;},
+      {representation = OptionalECImage; provider = PerceptionOptionalECImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PerceptionPenaltyMarkPerceptProvider;},
+      {representation = RobotCameraMatrix; provider = PerceptionRobotCameraMatrixProvider;},
+
+      {representation = ActivationGraph; provider = SkillBehaviorControl;},
+      {representation = AlternativeRobotPoseHypothesis; provider = AlternativeRobotPoseProvider;},
+      {representation = ArmMotionRequest; provider = SkillBehaviorControl;},
+      {representation = BallContactChecker; provider = BallContactCheckerProvider;},
+      {representation = BallDropInModel; provider = BallDropInLocator;},
+      {representation = BallInGoal; provider = BallInGoalTracker;},
+      {representation = BallModel; provider = BallStateEstimator;},
+      {representation = BallSearchAreas; provider = BallSearchAreasProvider;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BehaviorParameters; provider = ConfigurationDataProvider;},
+      {representation = BehaviorStatus; provider = SkillBehaviorControl;},
+      {representation = BHumanMessageOutputGenerator; provider = TeamMessageHandler;},
+      {representation = CameraCalibration; provider = AutomaticCameraCalibrator;},
+      {representation = CalibrationRequest; provider = SkillBehaviorControl;},
+      {representation = CameraCalibrationStatus; provider = AutomaticCameraCalibrator;},
+      {representation = CameraResolutionRequest; provider = AutomaticCameraCalibrator;},
+      {representation = DamageConfigurationBody; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = EnhancedKeyStates; provider = KeyStateEnhancer;},
+      {representation = ExpectedGoals; provider = ExpectedGoalsProvider;},
+      {representation = ExtendedGameState; provider = ExtendedGameStateProvider;},
+      {representation = ExecutedPasses; provider = ExecutedPassesProvider;},
+      {representation = FieldBall; provider = FieldBallProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldFeatureOverview; provider = FieldFeatureOverviewProvider;},
+      {representation = FieldRating; provider = FieldRatingProvider;},
+      {representation = FilteredBallPercepts; provider = BallPerceptFilter;},
+      {representation = GameControllerData; provider = GameControllerDataProvider;},
+      {representation = GameState; provider = GameStateProvider;},
+      {representation = GlobalOpponentsModel; provider = GlobalOpponentsTracker;},
+      {representation = GlobalTeammatesModel; provider = GlobalTeammatesTracker;},
+      {representation = GoaliePose; provider = GoaliePoseProvider;},
+      {representation = HeadLimits; provider = ConfigurationDataProvider;},
+      {representation = HeadMotionRequest; provider = SkillBehaviorControl;},
+      {representation = IllegalAreas; provider = IllegalAreaProvider;},
+      {representation = IMUCalibration; provider = IMUCalibrationProvider;},
+      {representation = JointLimits; provider = ConfigurationDataProvider;},
+      {representation = KickInfo; provider = ConfigurationDataProvider;},
+      {representation = LEDRequest; provider = LEDHandler;},
+      {representation = LibCheck; provider = LibCheckProvider;},
+      {representation = LibDemo; provider = LibDemoProvider;},
+      {representation = LibLookActive; provider = LibLookActiveProvider;},
+      {representation = LibPosition; provider = LibPositionProvider;},
+      {representation = LibTeammates; provider = LibTeammatesProvider;},
+      {representation = LibWalk; provider = LibWalkProvider;},
+      {representation = MotionRequest; provider = SkillBehaviorControl;},
+      {representation = ObstacleModel; provider = ObstacleModelProvider;},
+      {representation = Odometer; provider = OdometerProvider;},
+      {representation = OptionalImageRequest; provider = SkillBehaviorControl;},
+      {representation = PassEvaluation; provider = PassEvaluationProvider;},
+      {representation = PathPlanner; provider = PathPlannerProvider;},
+      {representation = PenaltyMarkWithPenaltyAreaLine; provider = PenaltyMarkWithPenaltyAreaLinePerceptor;},
+      {representation = PerceptRegistration; provider = PerceptRegistrationProvider;},
+      {representation = ReceivedTeamMessages; provider = TeamMessageHandler;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = RobotHealth; provider = RobotHealthProvider;},
+      {representation = RobotPose; provider = SelfLocator;},
+      {representation = SelfLocalizationHypotheses; provider = SelfLocator;},
+      {representation = SentTeamMessage; provider = TeamMessageHandler;},
+      {representation = SetupPoses; provider = SetupPosesProvider;},
+      {representation = SideInformation; provider = SideInformationProvider;},
+      {representation = SkillRequest; provider = StrategyBehaviorControl;},
+      {representation = StaticInitialPose; provider = StaticInitialPoseProvider;},
+      {representation = StrategyStatus; provider = StrategyBehaviorControl;},
+      {representation = TeammatesBallModel; provider = TeammatesBallModelProvider;},
+      {representation = TeamData; provider = TeamDataProvider;},
+      {representation = WorldModelPrediction; provider = WorldModelPredictor;},
+    ];
+  },{
+    name = Motion;
+    priority = 20;
+    debugReceiverSize = 500000;
+    debugSenderSize = 130000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Motion;
+    representationProviders = [
+      {representation = ArmContactModel; provider = ArmContactModelProvider;},
+      {representation = ArmKeyFrameGenerator; provider = ArmKeyFrameEngine;},
+      {representation = ArmMotionInfo; provider = MotionEngine;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = CameraIntrinsics; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationBody; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = DiveGenerator; provider = KeyframeMotionEngine;},
+      {representation = DribbleGenerator; provider = DribbleEngine;},
+      {representation = EnergySaving; provider = EnergySavingProvider;},
+      {representation = FallDownState; provider = FallDownStateProvider;},
+      {representation = FallGenerator; provider = FallEngine;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FilteredCurrent; provider = FilteredCurrentProvider;},
+      {representation = FootBumperState; provider = FootBumperStateProvider;},
+      {representation = FootSupport; provider = FootSupportProvider;},
+      {representation = FootOffset; provider = ConfigurationDataProvider;},
+      {representation = FrameInfo; provider = NaoProvider;},
+      {representation = FsrData; provider = FsrDataProvider;},
+      {representation = FsrSensorData; provider = NaoProvider;},
+      {representation = GetUpGenerator; provider = KeyframeMotionEngine;},
+      {representation = GroundContactState; provider = GroundContactDetector;},
+      {representation = GyroOffset; provider = GyroOffsetProvider;},
+      {representation = GyroState; provider = GyroStateProvider;},
+      {representation = HeadLimits; provider = ConfigurationDataProvider;},
+      {representation = HeadMotionGenerator; provider = HeadMotionEngine;},
+      {representation = HeadMotionInfo; provider = MotionEngine;},
+      {representation = InertialData; provider = InertialDataProvider;},
+      {representation = InertialSensorData; provider = NaoProvider;},
+      {representation = InterceptBallGenerator; provider = InterceptBallProviderDBHC;},
+      {representation = JointAnglePred; provider = JointAnglePredictor;},
+      {representation = JointAngles; provider = JointAnglesProvider;},
+      {representation = JointCalibration; provider = ConfigurationDataProvider;},
+      {representation = JointLimits; provider = ConfigurationDataProvider;},
+      {representation = JointPlay; provider = JointPlayProvider;},
+      {representation = JointPlayTranslation; provider = JointPlayTranslationProvider;},
+      {representation = JointRequest; provider = MotionEngine;},
+      {representation = JointSensorData; provider = NaoProvider;},
+      {representation = KeyframeMotionGenerator; provider = KeyframeMotionEngine;},
+      {representation = KeyframeMotionParameters; provider = ConfigurationDataProvider;},
+      {representation = KeyStates; provider = NaoProvider;},
+      {representation = KickGenerator; provider = KickEngine;},
+      {representation = KickInfo; provider = ConfigurationDataProvider;},
+      {representation = MassCalibration; provider = ConfigurationDataProvider;},
+      {representation = MotionInfo; provider = MotionEngine;},
+      {representation = MotionRobotHealth; provider = MotionRobotHealthProvider;},
+      {representation = OdometryData; provider = MotionEngine;},
+      {representation = OdometryDataPreview; provider = OdometryDataPreviewProvider;},
+      {representation = OdometryTranslationRequest; provider = OdometryDataPreviewProvider;},
+      {representation = PointAtGenerator; provider = PointAtEngine;},
+//      {representation = ReplayWalkRequestGenerator; provider = ReplayWalkRequestProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = RobotModel; provider = RobotModelProvider;},
+      {representation = RobotStableState; provider = RobotStableStateProvider;},
+      {representation = SpecialGenerator; provider = KeyframeMotionEngine;},
+      {representation = StandGenerator; provider = WalkingEngine;},
+      {representation = StaticJointPoses; provider = ConfigurationDataProvider;},
+      {representation = StiffnessSettings; provider = ConfigurationDataProvider;},
+      {representation = SystemSensorData; provider = NaoProvider;},
+      {representation = TorsoMatrix; provider = TorsoMatrixProvider;},
+      {representation = WalkAtAbsoluteSpeedGenerator; provider = WalkAtSpeedEngine;},
+      {representation = WalkAtRelativeSpeedGenerator; provider = WalkAtSpeedEngine;},
+      {representation = WalkGenerator; provider = WalkingEngine;},
+      {representation = WalkingEngineOutput; provider = WalkingEngine;},
+      {representation = WalkKickGenerator; provider = WalkKickEngine;},
+      {representation = WalkLearner; provider = WalkLearnerProvider;},
+      {representation = WalkModifier; provider = ConfigurationDataProvider;},
+      {representation = WalkStepData; provider = WalkingEngine;},
+      {representation = WalkToBallGenerator; provider = WalkToBallEngine;},
+      {representation = WalkToBallAndKickGenerator; provider = WalkToBallAndKickEngine;},
+      {representation = WalkToPoseGenerator; provider = WalkToPoseEngine;},
+    ];
+  },{
+    name = Audio;
+    priority = 0;
+    debugReceiverSize = 500000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Audio;
+    representationProviders = [
+      {representation = AudioData; provider = AudioProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = FrameInfo; provider = AudioProvider;},
+      {representation = Whistle; provider = WhistleRecognizer;},
+    ];
+  },
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeAttacker/walkingEngine.cfg b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/walkingEngine.cfg
new file mode 100644
index 0000000000..3ef2e95f40
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeAttacker/walkingEngine.cfg
@@ -0,0 +1,27 @@
+configuratedParameters = {
+  maxSpeed = {
+    rotation = 120deg;
+    translation = {x = 270; y = 230;};
+  };
+  minSpeed = {
+    rotation = 100deg;
+    translation = {x = 250; y = 230;};
+  };
+  maxSpeedBackwards = 150;
+  minSpeedBackwards = 125;
+  maxGyroBalanceKneeValue = 2deg;
+  emergencyNotMovingTime = 1000;
+  thresholdStopStandTransition = { rotation = 2deg; translation = { x = 5; y = 0.175; }; };
+  supportSwitchPhaseRange = { min = 0.5; max = 10; };
+  jointPlayOffsetParameters = {
+    applyOffsetFactor = 0.5;
+    applyOffsetFactorAnkle = 0.5;
+  };
+  walkSpeedParams = {
+    maxSpeed = {
+      rotation = 120deg;
+      translation = {x = 350; y = 300;};
+    };
+    maxSpeedBackwards = 250;
+  };
+};
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/BehaviorControl/passToTeammateImpl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/BehaviorControl/passToTeammateImpl.cfg
new file mode 100644
index 0000000000..24b0dabd4f
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/BehaviorControl/passToTeammateImpl.cfg
@@ -0,0 +1,28 @@
+allowedKicks = [
+  forwardFastRightPass,
+  forwardFastLeftPass,
+  walkForwardsRightLong,
+  walkForwardsLeftLong
+];
+doSpecialKickChecks = true;
+ratingThreshold = 0.7;
+passAheadDistance = 0;
+passTargetDistanceMinimum = 1600;
+minAngleOffset = 15deg;
+maxAngleOffset = 40deg;
+maxAngleOffsetBehind = 20deg;
+maxPrecisionOffset = 5deg;
+targetOffsetToFieldBorder = 800;
+maxTimeWaitingFactor = 0.1;
+averageKickExecutionTime = 800;
+averageKickBallOffset = {x = -185; y = 0;};
+ignoreObstaclesThreshold = 250;
+ignoreDynamicObstaclesThreshold = 500;
+standKickObstacleDistanceTreshold = 1000;
+lookAhead = true;
+maxLookAheadTime = 5000;
+interceptionDistanceThreshold = {min = 100; max = 400;};
+targetDistanceScale = {min = 0; max = 4000;};
+minRating = 0.01;
+rotationThresholdNear = 100deg;
+translationThresholdNear = 150;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/behaviorParameters.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/behaviorParameters.cfg
new file mode 100644
index 0000000000..b218ebd88a
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/behaviorParameters.cfg
@@ -0,0 +1,25 @@
+keeperJumpingOn = false; // jumping not allowed in dynamic ball handling challenge
+penaltyStrikerWalkSpeed = 0.7; // penalty striker must not walk at full speed; penalty keeper also uses this value
+penaltyStrikerAngleToLeftPostOffset = 10deg;
+penaltyStrikerAngleToRightPostOffset = 10deg;
+penaltyStrikerUseObstacles = true;
+ballCatchMaxWalkDistance = 1200;
+standRadius = 60;
+walkRadius = 125;
+genuflectRadius = 200;
+genuflectStandRadius = 200;
+jumpRadius = 600;
+
+//general free kick Parameters
+strikerWaitDistanceToBall = 150;
+maxDistanceForStanding = 50;
+maxAngleDifferenceForStanding = 4deg;
+keepTargetRotationDistance = 120;
+
+// TapFreeKick Parameters
+maxBallToGoalAngle = 50deg;
+maxBallToGoalDistance = 4000;
+ignoreTeammateTime = 22000;
+timeLeftAfterSupporterIsInPosition = 3700;
+yOffsetWaitPosition = 650;
+xOffsetWaitPosition = 300;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/gameStateProvider.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/gameStateProvider.cfg
new file mode 100644
index 0000000000..131dbd7455
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/gameStateProvider.cfg
@@ -0,0 +1,30 @@
+unstiffHeadButtonPressDuration = 1000; // [ms]
+calibrationHeadButtonPressDuration = 200; // [ms]
+unstiffAfterHalfDuration = 7777; // [ms]
+gameControllerTimeout = 2000; // [ms]
+ballSaveInterval = 100; // [ms]
+ballHasMovedTolerance = 100; // [mm]
+ballHasMovedCloseToRobotThreshold = 300; // [mm]
+ballOutOfCenterCircleCounterThreshold = 10;
+ballOutOfCenterCircleTolerance = 200; // [mm]
+maxWhistleTimeDifference = 1000; // [ms]
+minVotersForWhistle = 3;
+minWhistleAverageConfidence = 1.15;
+ignoreWhistleAfterKickOff = 5000; // [ms]
+ignoreWhistleAfterPenaltyKick = 2000; // [ms]
+checkWhistleForGoal = false;
+checkBallForGoal = false;
+gameControllerOperatorDelay = 3000; // [ms]
+acceptBallInGoalDelay = 5000; // [ms]
+acceptPastWhistleDelay = 3000; // [ms]
+confidenceIntervalToLegalPositionFree = 0.99; // [no unit]
+confidenceIntervalToLegalPositionNotFree = 0.999; // [no unit]
+ballPlacementTolerance = 50; // [mm]
+
+kickOffSetupDuration = 45000; // [ms]
+kickOffDuration = 10000; // [ms]
+penaltyKickSetupDuration = 30000; // [ms]
+penaltyKickDuration = 30000; // [ms]
+freeKickDuration = 30000; // [ms]
+playingSignalDelay = 15000; // [ms]
+goalSignalDelay = 15000; // [ms]
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/logger.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/logger.cfg
new file mode 100644
index 0000000000..dbe4cc234c
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/logger.cfg
@@ -0,0 +1,123 @@
+// Is logging enabled?
+enabled = true;
+
+// The directory that will contain the log file.
+path = "/home/nao/logging";
+
+// The number of buffers allocated.
+numOfBuffers = 12000;
+
+// The size of each buffer in bytes.
+sizeOfBuffer = 200000;
+
+// The scheduling priority of the writer thread.
+writePriority = -2;
+
+// Logging will stop if less MB are available to the target device.
+minFreeDriveSpace = 100;
+
+// Representations to log per thread
+representationsPerThread = [
+  {
+    thread = Upper;
+    representations = [
+      JPEGImage,
+
+      BallPercept,
+      BallSpots,
+      BodyContour,
+      CameraInfo,
+      CameraMatrix,
+      CirclePercept,
+      FieldBoundary,
+      FrameInfo,
+      ImageCoordinateSystem,
+      LinesPercept,
+      ObstaclesFieldPercept,
+      ObstaclesImagePercept,
+      OdometryData,
+      PenaltyMarkPercept,
+    ];
+  },
+  {
+    thread = Lower;
+    representations = [
+      JPEGImage,
+
+      BallPercept,
+      BallSpots,
+      BodyContour,
+      CameraInfo,
+      CameraMatrix,
+      CirclePercept,
+      FieldBoundary,
+      FrameInfo,
+      ImageCoordinateSystem,
+      LinesPercept,
+      ObstaclesFieldPercept,
+      ObstaclesImagePercept,
+      OdometryData,
+      PenaltyMarkPercept,
+    ];
+  },
+  {
+    thread = Cognition;
+    representations = [
+      ActivationGraph,
+      AlternativeRobotPoseHypothesis,
+      ArmMotionRequest,
+      BallModel,
+      BehaviorStatus,
+      CameraCalibration,
+      GameState,
+      IMUCalibration,
+      MotionRequest,
+      ObstacleModel,
+      OdometryData,
+      ReceivedTeamMessages,
+      RobotHealth,
+      RobotPose,
+      SelfLocalizationHypotheses,
+      SideInformation,
+      SkillRequest,
+      StrategyStatus,
+      TeammatesBallModel,
+      TeamData,
+    ];
+  },
+  {
+    thread = Motion;
+    representations = [
+      FallDownState,
+      FootOffset,
+      FootSupport,
+      FrameInfo,
+      FsrData,
+      FsrSensorData,
+      GroundContactState,
+      GyroState,
+      InertialSensorData,
+      InertialData,
+      JointAnglePred,
+      JointCalibration,
+      JointPlay,
+      JointRequest,
+      JointSensorData,
+      KeyStates,
+      MotionInfo,
+      OdometryData,
+      OdometryDataPreview,
+      SystemSensorData,
+      RobotStableState,
+      WalkLearner,
+      WalkStepData,
+    ];
+  },
+  {
+    thread = Audio;
+    representations = [
+      AudioData,
+      FrameInfo,
+    ];
+  }
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/selfLocator.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/selfLocator.cfg
new file mode 100644
index 0000000000..56c23c21a1
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/selfLocator.cfg
@@ -0,0 +1,67 @@
+numberOfSamples = 12;
+
+defaultPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 500; y = 500;};
+    };
+walkInPoseDeviation = {
+      rotation = 12deg;
+      translation = {x = 500; y = 1000;};
+    };
+returnFromPenaltyPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 700; y = 200;};
+    };
+manualPlacementPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 500; y = 500;};
+    };
+penaltyShootoutPoseDeviation = {
+      rotation = 9deg;
+      translation = {x = 200; y = 200;};
+    };
+filterProcessDeviation = {
+      rotation = 0.002;
+      translation = {x = 2.0; y = 2.0;};
+    };
+odometryDeviation  = {
+      rotation = 0.3;
+      translation = {x = 0.2; y = 0.2;};
+    };
+odometryRotationDeviation  = {
+      x = 0.00157;
+      y = 0.00157;
+    };
+
+movedDistWeightRotationNoise = 0.0005;
+movedAngleWeightRotationNoise = 0.25;
+movedAngleWeightRotationNoiseNotWalking = 0.075;
+majorDirTransWeight = 2;
+minorDirTransWeight = 1;
+
+minValidityForSuperbLocalizationQuality = 0.8;
+maxTranslationDeviationForSuperbLocalizationQuality = 100.0;
+maxRotationalDeviationForSuperbLocalizationQuality = 10deg;
+baseValidityWeighting = 0.1;
+numberOfConsideredFramesForValidity  = 60;
+considerLinesForValidityComputation = true;
+validityFactorPoseMeasurement = 5;
+validityFactorLandmarkMeasurement = 3;
+validityFactorLineMeasurement = 1;
+
+positionJumpNotificationDistance = 2000.0;
+
+minNumberOfObservationsForResetting = 6;
+translationalDeviationForResetting = 1500.0;
+rotationalDeviationForResetting = 0.5;
+returnFromPenaltyMaxXOffset = 250.0;
+
+demoUseCustomReturnFromPenaltyPoses = false;
+demoCustomReturnFromPenaltyPoseGoalie = {
+      rotation = 0deg;
+      translation = {x = -2000.0; y = 0.0;};
+    };
+demoCustomReturnFromPenaltyPoseFieldPlayer = {
+      rotation = 0deg;
+      translation = {x = -750.0; y = 0.0;};
+    };
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/setupPosesProvider.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/setupPosesProvider.cfg
new file mode 100644
index 0000000000..20a307c37f
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/setupPosesProvider.cfg
@@ -0,0 +1,25 @@
+// Positions as defined in the latest version of the rule book:
+// DEFENDERS ONLY:
+// - goalkeeper on the goal line between the two goal posts;
+// - front line of penalty area;
+// - within center circle;
+poses = [
+  // Note: The SetupPosesProvider will randomize these setup positions within the player's corresponding area as defined in the challenge rules.
+  {
+    playerNumber = 1;                     /*< The player number of the robot */
+    position = {x = -4500; y = 0;};       /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = 0;};      /*< The position (in global field coordinates) at which the robot is turned */
+  },
+  {
+    playerNumber = 2;                     /*< The player number of the robot */
+    position = {x = -2850; y = -1000;};       /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = -1000;};      /*< The position (in global field coordinates) at which the robot is turned */
+  },
+  {
+    playerNumber = 3;                     /*< The player number of the robot */
+    position = {x = -375; y = 0;};           /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = 0;};   /*< The position (in global field coordinates) at which the robot is turned */
+  },
+ // Other player numbers are not defined here. In case a robot is deployed with number 4 - 7,
+ // an assert will terminate the software :-)
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/skillBehaviorControl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/skillBehaviorControl.cfg
new file mode 100644
index 0000000000..b9ca41dc75
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/skillBehaviorControl.cfg
@@ -0,0 +1,18 @@
+options = [
+  HandlePhysicalRobot,
+  HandlePlayerState,
+  HandleGameState,
+];
+
+playingOptions = [
+  HandleGoalkeeperCatchBall,
+  HandleStrikerLostBall,
+  HandleCatchBall,
+];
+
+useNewHandleCatchBallBehavior = false;
+
+// Referee Challenge options
+refereeXRange = {min = -1000; max = 800;};
+refereeYRange = {min = 0; max = 1900;};
+refereeDuration = 10000;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/strategyBehaviorControl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/strategyBehaviorControl.cfg
new file mode 100644
index 0000000000..47db364ce4
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/strategyBehaviorControl.cfg
@@ -0,0 +1 @@
+strategy = dbhc;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/teamMessage.def b/Config/Scenarios/DynamicBallHandlingChallengeDefender/teamMessage.def
new file mode 100644
index 0000000000..e7f04b30c0
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/teamMessage.def
@@ -0,0 +1,92 @@
+RobotPoseCompact
+{
+  rotation: Angle(bits=8)
+  translation: Vector<Float(min=-5120, max=5110, bits=10)>(n=2)
+  quality: Enum(type=RobotPose::LocalizationQuality)
+  covariance: Matrix<Integer(min=-32768, max=32767)>(m=2, n=2, symmetric) // Is actually something like Matrix<float16_t>
+  timestampLastJump: Timestamp(bits=1, shift=10, reference=relativePast, noclip)
+}
+
+RobotStatus
+{
+  isUpright: Boolean
+  timeWhenLastUpright: Timestamp(bits=8, shift=6, reference=relativePast)
+}
+
+BallState
+{
+  position: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)
+  velocity: Vector<Float(min=-8000, max=8000, bits=11)>(n=2)
+  // covariance: Matrix<Float>(m=2, n=2, symmetric) // Unused
+}
+
+BallModel
+{
+  // lastPerception: Vector<Float(min=-32768, max=32767, bits=16)>(n=2) // Unused
+  estimate: BallState
+  timeWhenDisappeared: Timestamp(bits=9, shift=6, reference=relativePast, noclip)
+  timeWhenLastSeen: Timestamp(bits=11, shift=4, reference=relativePast, noclip)
+  // seenPercentage: Integer(min=0, max=100) // Unused
+}
+
+RecentWhistle
+{
+  confidenceOfLastWhistleDetection: Float(min=0, max=2.55, bits=8)
+  lastTimeWhistleDetected: Timestamp(bits=8, shift=4, reference=relativePast, noclip)
+}
+
+WhistleCompact
+{
+  listening: Boolean
+  recentWhistle: RecentWhistle[:1]
+}
+
+BehaviorStatus
+{
+  passTarget: Integer(min=-1, max=14)
+  walkingTo: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)
+  speed: Float(min=0.0, max=310.0, bits=5)
+  shootingTo: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)[:1]
+  lastKickTimestamp: Timestamp
+}
+
+StrategyStatus
+{
+  proposedTactic: Enum(type=Tactic::Type)
+  acceptedTactic: Enum(type=Tactic::Type)
+  proposedMirror: Boolean
+  acceptedMirror: Boolean
+  proposedSetPlay: Enum(type=SetPlay::Type)
+  acceptedSetPlay: Enum(type=SetPlay::Type)
+  position: Enum(type=Tactic::Position::Type)
+  role: Enum(type=Role::Type)
+}
+
+Obstacle
+{
+  center: Vector<Float(min=-32768, max=32767, bits=16)>(n=2)
+  lastSeen: Timestamp(bits=8, shift=6, reference=relativePast)
+  type: Enum(type=Obstacle::Type)
+}
+
+ObstacleModel
+{
+  obstacles: Obstacle[:3]
+}
+
+FrameInfo
+{
+  time: Timestamp(bits=0, reference=relativePast)
+}
+
+TeamMessage
+{
+  theRobotPose: RobotPoseCompact
+  theRobotStatus: RobotStatus
+  theFrameInfo: FrameInfo
+  theBallModel: BallModel
+  theWhistle: WhistleCompact
+  theBehaviorStatus: BehaviorStatus
+  theStrategyStatus: StrategyStatus
+  theObstacleModel: ObstacleModel
+}
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/teamMessageHandler.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/teamMessageHandler.cfg
new file mode 100644
index 0000000000..77aedcc8b2
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/teamMessageHandler.cfg
@@ -0,0 +1,19 @@
+minSendInterval = 650;
+durationOfHalf = 240000;
+overallMessageBudget = 1200;
+normalMessageReserve = 20;
+priorityMessageReserve = 10;
+lookahead = 5000;
+positionThreshold = 200;
+bearingThreshold = 3deg;
+assumedObservationHeight = 450;
+teamBallThresholdBase = 9000;
+teamBallThresholdFactor = 500;
+newBallThreshold = 500;
+disappearedThreshold = 3000;
+ignoreWhistleBeforeEndOfHalf = 5000;
+maxWhistleSendDelay = 4000;
+minTimeBetween2RejectSounds = 5000;
+sendMirroredRobotPose = false;
+dropUnsynchronizedMessages = true;
+alwaysSend = true;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/threads.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/threads.cfg
new file mode 100644
index 0000000000..750d12bd1c
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/threads.cfg
@@ -0,0 +1,302 @@
+defaultRepresentations = [
+  CalibrationGenerator,
+  GroundTruthRobotPose,
+  RefereePercept,
+  ReplayWalkRequestGenerator,
+  Whistle,
+];
+threads = [
+  {
+    name = Upper;
+    priority = 0;
+    debugReceiverSize = 2800000;
+    debugSenderSize = 5200000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Perception;
+    representationProviders = [
+      {representation = OtherFieldBoundary; provider = LowerProvider;},
+      {representation = OtherObstaclesPerceptorData; provider = LowerProvider;},
+      {representation = OtherOdometryData; provider = LowerProvider;},
+
+      {representation = AutoExposureWeightTable; provider = AutoExposureWeightTableProvider;},
+      {representation = BallPercept; provider = BallPerceptor;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BallSpots; provider = BallSpotsProvider;},
+      {representation = BodyContour; provider = BodyContourProvider;},
+      {representation = CameraImage; provider = CameraProvider;},
+      {representation = CameraInfo; provider = CameraProvider;},
+      {representation = CameraIntrinsics; provider = CameraProvider;},
+      {representation = CameraMatrix; provider = CameraMatrixProvider;},
+      {representation = CameraSettings; provider = ConfigurationDataProvider;},
+      {representation = CameraStatus; provider = CameraProvider;},
+      {representation = CirclePercept; provider = LinePerceptor;},
+      {representation = ColorScanLineRegionsHorizontal; provider = ScanLineRegionizer;},
+      {representation = ColorScanLineRegionsVerticalClipped; provider = ScanLineRegionizer;},
+      {representation = ECImage; provider = ECImageProvider;},
+      {representation = FieldBoundary; provider = FieldBoundaryProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldLineIntersections; provider = FieldLinesProvider;},
+      {representation = FieldLines; provider = FieldLinesProvider;},
+      {representation = FrameInfo; provider = CameraProvider;},
+      {representation = ImageCoordinateSystem; provider = CoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = IntersectionsProvider;},
+      {representation = JerseyClassifier; provider = JerseyClassifierProvider2020For2023;},
+      {representation = JPEGImage; provider = CameraProvider;},
+      {representation = LinesPercept; provider = LinePerceptor;},
+      {representation = MeasurementCovariance; provider = LegacyMeasurementCovarianceProvider;},
+      {representation = ObstaclesFieldPercept; provider = RobotDetector;},
+      {representation = ObstaclesImagePercept; provider = RobotDetector;},
+      {representation = ObstaclesPerceptorData; provider = RobotDetector;},
+      {representation = OdometryData; provider = ImageFrameProvider;},
+      {representation = OptionalECImage; provider = ECImageProvider;},
+      {representation = OptionalCameraImage; provider = OptionalCameraImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PenaltyMarkPerceptor;},
+      {representation = PenaltyMarkRegions; provider = PenaltyMarkRegionsProvider;},
+      {representation = RelativeFieldColors; provider = RelativeFieldColorsProvider;},
+      {representation = RelativeFieldColorsParameters; provider = ConfigurationDataProvider;},
+      {representation = RobotCameraMatrix; provider = RobotCameraMatrixProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = ScanGrid; provider = ScanGridProvider;},
+    ];
+  }, {
+    name = Lower;
+    priority = 0;
+    debugReceiverSize = 1000000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Perception;
+    representationProviders = [
+      {representation = OtherFieldBoundary; provider = UpperProvider;},
+      {representation = OtherObstaclesPerceptorData; provider = UpperProvider;},
+      {representation = OtherOdometryData; provider = UpperProvider;},
+
+      {representation = AutoExposureWeightTable; provider = AutoExposureWeightTableProvider;},
+      {representation = BallPercept; provider = BallPerceptor;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BallSpots; provider = BOPPerceptor;},
+      {representation = BodyContour; provider = BodyContourProvider;},
+      {representation = CameraImage; provider = CameraProvider;},
+      {representation = CameraInfo; provider = CameraProvider;},
+      {representation = CameraIntrinsics; provider = CameraProvider;},
+      {representation = CameraMatrix; provider = CameraMatrixProvider;},
+      {representation = CameraSettings; provider = ConfigurationDataProvider;},
+      {representation = CameraStatus; provider = CameraProvider;},
+      {representation = CirclePercept; provider = LinePerceptor;},
+      {representation = ColorScanLineRegionsHorizontal; provider = ScanLineRegionizer;},
+      {representation = ColorScanLineRegionsVerticalClipped; provider = ScanLineRegionizer;},
+      {representation = ECImage; provider = ECImageProvider;},
+      {representation = FieldBoundary; provider = FieldBoundaryProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldLineIntersections; provider = FieldLinesProvider;},
+      {representation = FieldLines; provider = FieldLinesProvider;},
+      {representation = FrameInfo; provider = CameraProvider;},
+      {representation = ImageCoordinateSystem; provider = CoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = IntersectionsProvider;},
+      {representation = JerseyClassifier; provider = JerseyClassifierProvider2020For2023;},
+      {representation = JPEGImage; provider = CameraProvider;},
+      {representation = LinesPercept; provider = LinePerceptor;},
+      {representation = MeasurementCovariance; provider = LegacyMeasurementCovarianceProvider;},
+      {representation = ObstaclesFieldPercept; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = ObstaclesImagePercept; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = ObstaclesPerceptorData; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = OdometryData; provider = ImageFrameProvider;},
+      {representation = OptionalECImage; provider = ECImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PenaltyMarkPerceptor;},
+      {representation = PenaltyMarkRegions; provider = BOPPerceptor;},
+      {representation = RelativeFieldColors; provider = RelativeFieldColorsProvider;},
+      {representation = RelativeFieldColorsParameters; provider = ConfigurationDataProvider;},
+      {representation = RobotCameraMatrix; provider = RobotCameraMatrixProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = ScanGrid; provider = ScanGridProvider;},
+      {representation = SegmentedObstacleImage; provider = BOPPerceptor;},
+    ];
+  }, {
+    name = Cognition;
+    priority = 1;
+    debugReceiverSize = 2000000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 200000;
+    executionUnit = Cognition;
+    representationProviders = [
+      {representation = BallPercept; provider = PerceptionBallPerceptProvider;},
+      {representation = BodyContour; provider = PerceptionBodyContourProvider;},
+      {representation = CameraInfo; provider = PerceptionCameraInfoProvider;},
+      {representation = CameraMatrix; provider = PerceptionCameraMatrixProvider;},
+      {representation = CameraStatus; provider = PerceptionCameraStatusProvider;},
+      {representation = CenterCircleWithLine; provider = CenterCircleWithLinePerceptor;},
+      {representation = CirclePercept; provider = PerceptionCirclePerceptProvider;},
+      {representation = FieldBoundary; provider = PerceptionFieldBoundaryProvider;},
+      {representation = FieldLines; provider = PerceptionFieldLinesProvider;},
+      {representation = FieldLineIntersections; provider = PerceptionFieldLineIntersectionsProvider;},
+      {representation = FrameInfo; provider = PerceptionFrameInfoProvider;},
+      {representation = ImageCoordinateSystem; provider = PerceptionImageCoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = PerceptionIntersectionsPerceptProvider;},
+      {representation = LinesPercept; provider = PerceptionLinesPerceptProvider;},
+      {representation = ObstaclesFieldPercept; provider = PerceptionObstaclesFieldPerceptProvider;},
+      {representation = OdometryData; provider = MotionProvider;},
+      {representation = OptionalECImage; provider = PerceptionOptionalECImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PerceptionPenaltyMarkPerceptProvider;},
+      {representation = RobotCameraMatrix; provider = PerceptionRobotCameraMatrixProvider;},
+
+      {representation = ActivationGraph; provider = SkillBehaviorControl;},
+      {representation = AlternativeRobotPoseHypothesis; provider = AlternativeRobotPoseProvider;},
+      {representation = ArmMotionRequest; provider = SkillBehaviorControl;},
+      {representation = BallContactChecker; provider = BallContactCheckerProvider;},
+      {representation = BallDropInModel; provider = BallDropInLocator;},
+      {representation = BallInGoal; provider = BallInGoalTracker;},
+      {representation = BallModel; provider = BallStateEstimator;},
+      {representation = BallSearchAreas; provider = BallSearchAreasProvider;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BehaviorParameters; provider = ConfigurationDataProvider;},
+      {representation = BehaviorStatus; provider = SkillBehaviorControl;},
+      {representation = BHumanMessageOutputGenerator; provider = TeamMessageHandler;},
+      {representation = CameraCalibration; provider = AutomaticCameraCalibrator;},
+      {representation = CalibrationRequest; provider = SkillBehaviorControl;},
+      {representation = CameraCalibrationStatus; provider = AutomaticCameraCalibrator;},
+      {representation = CameraResolutionRequest; provider = AutomaticCameraCalibrator;},
+      {representation = DamageConfigurationBody; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = EnhancedKeyStates; provider = KeyStateEnhancer;},
+      {representation = ExpectedGoals; provider = ExpectedGoalsProvider;},
+      {representation = ExecutedPasses; provider = ExecutedPassesProvider;},
+      {representation = ExtendedGameState; provider = ExtendedGameStateProvider;},
+      {representation = FieldBall; provider = FieldBallProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldFeatureOverview; provider = FieldFeatureOverviewProvider;},
+      {representation = FieldRating; provider = FieldRatingProvider;},
+      {representation = FilteredBallPercepts; provider = BallPerceptFilter;},
+      {representation = GameControllerData; provider = GameControllerDataProvider;},
+      {representation = GameState; provider = GameStateProvider;},
+      {representation = GlobalOpponentsModel; provider = GlobalOpponentsTracker;},
+      {representation = GlobalTeammatesModel; provider = GlobalTeammatesTracker;},
+      {representation = GoaliePose; provider = GoaliePoseProvider;},
+      {representation = HeadLimits; provider = ConfigurationDataProvider;},
+      {representation = HeadMotionRequest; provider = SkillBehaviorControl;},
+      {representation = IllegalAreas; provider = IllegalAreaProvider;},
+      {representation = IMUCalibration; provider = IMUCalibrationProvider;},
+      {representation = JointLimits; provider = ConfigurationDataProvider;},
+      {representation = KickInfo; provider = ConfigurationDataProvider;},
+      {representation = LEDRequest; provider = LEDHandler;},
+      {representation = LibCheck; provider = LibCheckProvider;},
+      {representation = LibDemo; provider = LibDemoProvider;},
+      {representation = LibLookActive; provider = LibLookActiveProvider;},
+      {representation = LibPosition; provider = LibPositionProvider;},
+      {representation = LibTeammates; provider = LibTeammatesProvider;},
+      {representation = LibWalk; provider = LibWalkProvider;},
+      {representation = MotionRequest; provider = SkillBehaviorControl;},
+      {representation = ObstacleModel; provider = ObstacleModelProvider;},
+      {representation = Odometer; provider = OdometerProvider;},
+      {representation = OptionalImageRequest; provider = SkillBehaviorControl;},
+      {representation = PassEvaluation; provider = PassEvaluationProvider;},
+      {representation = PathPlanner; provider = PathPlannerProvider;},
+      {representation = PenaltyMarkWithPenaltyAreaLine; provider = PenaltyMarkWithPenaltyAreaLinePerceptor;},
+      {representation = PerceptRegistration; provider = PerceptRegistrationProvider;},
+      {representation = ReceivedTeamMessages; provider = TeamMessageHandler;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = RobotHealth; provider = RobotHealthProvider;},
+      {representation = RobotPose; provider = SelfLocator;},
+      {representation = SelfLocalizationHypotheses; provider = SelfLocator;},
+      {representation = SentTeamMessage; provider = TeamMessageHandler;},
+      {representation = SetupPoses; provider = SetupPosesProvider;},
+      {representation = SideInformation; provider = SideInformationProvider;},
+      {representation = SkillRequest; provider = StrategyBehaviorControlDBHDefender;},
+      {representation = StaticInitialPose; provider = StaticInitialPoseProvider;},
+      {representation = StrategyStatus; provider = StrategyBehaviorControl;},
+      {representation = TeammatesBallModel; provider = TeammatesBallModelProvider;},
+      {representation = TeamData; provider = TeamDataProvider;},
+      {representation = WorldModelPrediction; provider = WorldModelPredictor;},
+    ];
+  },{
+    name = Motion;
+    priority = 20;
+    debugReceiverSize = 500000;
+    debugSenderSize = 130000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Motion;
+    representationProviders = [
+      {representation = ArmContactModel; provider = ArmContactModelProvider;},
+      {representation = ArmKeyFrameGenerator; provider = ArmKeyFrameEngine;},
+      {representation = ArmMotionInfo; provider = MotionEngine;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = CameraIntrinsics; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationBody; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = DiveGenerator; provider = KeyframeMotionEngine;},
+      {representation = DribbleGenerator; provider = DribbleEngine;},
+      {representation = EnergySaving; provider = EnergySavingProvider;},
+      {representation = FallDownState; provider = FallDownStateProvider;},
+      {representation = FallGenerator; provider = FallEngine;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FilteredCurrent; provider = FilteredCurrentProvider;},
+      {representation = FootBumperState; provider = FootBumperStateProvider;},
+      {representation = FootSupport; provider = FootSupportProvider;},
+      {representation = FootOffset; provider = ConfigurationDataProvider;},
+      {representation = FrameInfo; provider = NaoProvider;},
+      {representation = FsrData; provider = FsrDataProvider;},
+      {representation = FsrSensorData; provider = NaoProvider;},
+      {representation = GetUpGenerator; provider = KeyframeMotionEngine;},
+      {representation = GroundContactState; provider = GroundContactDetector;},
+      {representation = GyroOffset; provider = GyroOffsetProvider;},
+      {representation = GyroState; provider = GyroStateProvider;},
+      {representation = HeadLimits; provider = ConfigurationDataProvider;},
+      {representation = HeadMotionGenerator; provider = HeadMotionEngine;},
+      {representation = HeadMotionInfo; provider = MotionEngine;},
+      {representation = InertialData; provider = InertialDataProvider;},
+      {representation = InertialSensorData; provider = NaoProvider;},
+      {representation = InterceptBallGenerator; provider = InterceptBallProvider;},
+      {representation = JointAnglePred; provider = JointAnglePredictor;},
+      {representation = JointAngles; provider = JointAnglesProvider;},
+      {representation = JointCalibration; provider = ConfigurationDataProvider;},
+      {representation = JointLimits; provider = ConfigurationDataProvider;},
+      {representation = JointPlay; provider = JointPlayProvider;},
+      {representation = JointPlayTranslation; provider = JointPlayTranslationProvider;},
+      {representation = JointRequest; provider = MotionEngine;},
+      {representation = JointSensorData; provider = NaoProvider;},
+      {representation = KeyframeMotionGenerator; provider = KeyframeMotionEngine;},
+      {representation = KeyframeMotionParameters; provider = ConfigurationDataProvider;},
+      {representation = KeyStates; provider = NaoProvider;},
+      {representation = KickGenerator; provider = KickEngine;},
+      {representation = KickInfo; provider = ConfigurationDataProvider;},
+      {representation = MassCalibration; provider = ConfigurationDataProvider;},
+      {representation = MotionInfo; provider = MotionEngine;},
+      {representation = MotionRobotHealth; provider = MotionRobotHealthProvider;},
+      {representation = OdometryData; provider = MotionEngine;},
+      {representation = OdometryDataPreview; provider = OdometryDataPreviewProvider;},
+      {representation = OdometryTranslationRequest; provider = OdometryDataPreviewProvider;},
+      {representation = PointAtGenerator; provider = PointAtEngine;},
+//      {representation = ReplayWalkRequestGenerator; provider = ReplayWalkRequestProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = RobotModel; provider = RobotModelProvider;},
+      {representation = RobotStableState; provider = RobotStableStateProvider;},
+      {representation = SpecialGenerator; provider = KeyframeMotionEngine;},
+      {representation = StandGenerator; provider = WalkingEngine;},
+      {representation = StaticJointPoses; provider = ConfigurationDataProvider;},
+      {representation = StiffnessSettings; provider = ConfigurationDataProvider;},
+      {representation = SystemSensorData; provider = NaoProvider;},
+      {representation = TorsoMatrix; provider = TorsoMatrixProvider;},
+      {representation = WalkAtAbsoluteSpeedGenerator; provider = WalkAtSpeedEngine;},
+      {representation = WalkAtRelativeSpeedGenerator; provider = WalkAtSpeedEngine;},
+      {representation = WalkGenerator; provider = WalkingEngine;},
+      {representation = WalkingEngineOutput; provider = WalkingEngine;},
+      {representation = WalkKickGenerator; provider = WalkKickEngine;},
+      {representation = WalkLearner; provider = WalkLearnerProvider;},
+      {representation = WalkModifier; provider = ConfigurationDataProvider;},
+      {representation = WalkStepData; provider = WalkingEngine;},
+      {representation = WalkToBallGenerator; provider = WalkToBallEngine;},
+      {representation = WalkToBallAndKickGenerator; provider = WalkToBallAndKickEngine;},
+      {representation = WalkToPoseGenerator; provider = WalkToPoseEngine;},
+    ];
+  },{
+    name = Audio;
+    priority = 0;
+    debugReceiverSize = 500000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Audio;
+    representationProviders = [
+      {representation = AudioData; provider = AudioProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = FrameInfo; provider = AudioProvider;},
+    ];
+  },
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDefender/walkingEngine.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDefender/walkingEngine.cfg
new file mode 100644
index 0000000000..d03cfb1661
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDefender/walkingEngine.cfg
@@ -0,0 +1,27 @@
+configuratedParameters = {
+  maxSpeed = { // translation reduced by *0.66 due to speed limit in challenge
+    rotation = 120deg;
+    translation = {x = 166; y = 166;};
+  };
+  minSpeed = {
+    rotation = 90deg;
+    translation = {x = 150; y = 150;};
+  };
+  maxSpeedBackwards = 150;
+  minSpeedBackwards = 125;
+  maxGyroBalanceKneeValue = 2deg;
+  emergencyNotMovingTime = 1000;
+  thresholdStopStandTransition = { rotation = 2deg; translation = { x = 5; y = 0.175; }; };
+  supportSwitchPhaseRange = { min = 0.5; max = 10; };
+  jointPlayOffsetParameters = {
+    applyOffsetFactor = 0.5;
+    applyOffsetFactorAnkle = 0.5;
+  };
+  walkSpeedParams = {
+    maxSpeed = {
+      rotation = 120deg;
+      translation = {x = 350; y = 300;};
+    };
+    maxSpeedBackwards = 250;
+  };
+};
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/BehaviorControl/passToTeammateImpl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/BehaviorControl/passToTeammateImpl.cfg
new file mode 100644
index 0000000000..24b0dabd4f
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/BehaviorControl/passToTeammateImpl.cfg
@@ -0,0 +1,28 @@
+allowedKicks = [
+  forwardFastRightPass,
+  forwardFastLeftPass,
+  walkForwardsRightLong,
+  walkForwardsLeftLong
+];
+doSpecialKickChecks = true;
+ratingThreshold = 0.7;
+passAheadDistance = 0;
+passTargetDistanceMinimum = 1600;
+minAngleOffset = 15deg;
+maxAngleOffset = 40deg;
+maxAngleOffsetBehind = 20deg;
+maxPrecisionOffset = 5deg;
+targetOffsetToFieldBorder = 800;
+maxTimeWaitingFactor = 0.1;
+averageKickExecutionTime = 800;
+averageKickBallOffset = {x = -185; y = 0;};
+ignoreObstaclesThreshold = 250;
+ignoreDynamicObstaclesThreshold = 500;
+standKickObstacleDistanceTreshold = 1000;
+lookAhead = true;
+maxLookAheadTime = 5000;
+interceptionDistanceThreshold = {min = 100; max = 400;};
+targetDistanceScale = {min = 0; max = 4000;};
+minRating = 0.01;
+rotationThresholdNear = 100deg;
+translationThresholdNear = 150;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/behaviorParameters.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/behaviorParameters.cfg
new file mode 100644
index 0000000000..b218ebd88a
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/behaviorParameters.cfg
@@ -0,0 +1,25 @@
+keeperJumpingOn = false; // jumping not allowed in dynamic ball handling challenge
+penaltyStrikerWalkSpeed = 0.7; // penalty striker must not walk at full speed; penalty keeper also uses this value
+penaltyStrikerAngleToLeftPostOffset = 10deg;
+penaltyStrikerAngleToRightPostOffset = 10deg;
+penaltyStrikerUseObstacles = true;
+ballCatchMaxWalkDistance = 1200;
+standRadius = 60;
+walkRadius = 125;
+genuflectRadius = 200;
+genuflectStandRadius = 200;
+jumpRadius = 600;
+
+//general free kick Parameters
+strikerWaitDistanceToBall = 150;
+maxDistanceForStanding = 50;
+maxAngleDifferenceForStanding = 4deg;
+keepTargetRotationDistance = 120;
+
+// TapFreeKick Parameters
+maxBallToGoalAngle = 50deg;
+maxBallToGoalDistance = 4000;
+ignoreTeammateTime = 22000;
+timeLeftAfterSupporterIsInPosition = 3700;
+yOffsetWaitPosition = 650;
+xOffsetWaitPosition = 300;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/gameStateProvider.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/gameStateProvider.cfg
new file mode 100644
index 0000000000..131dbd7455
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/gameStateProvider.cfg
@@ -0,0 +1,30 @@
+unstiffHeadButtonPressDuration = 1000; // [ms]
+calibrationHeadButtonPressDuration = 200; // [ms]
+unstiffAfterHalfDuration = 7777; // [ms]
+gameControllerTimeout = 2000; // [ms]
+ballSaveInterval = 100; // [ms]
+ballHasMovedTolerance = 100; // [mm]
+ballHasMovedCloseToRobotThreshold = 300; // [mm]
+ballOutOfCenterCircleCounterThreshold = 10;
+ballOutOfCenterCircleTolerance = 200; // [mm]
+maxWhistleTimeDifference = 1000; // [ms]
+minVotersForWhistle = 3;
+minWhistleAverageConfidence = 1.15;
+ignoreWhistleAfterKickOff = 5000; // [ms]
+ignoreWhistleAfterPenaltyKick = 2000; // [ms]
+checkWhistleForGoal = false;
+checkBallForGoal = false;
+gameControllerOperatorDelay = 3000; // [ms]
+acceptBallInGoalDelay = 5000; // [ms]
+acceptPastWhistleDelay = 3000; // [ms]
+confidenceIntervalToLegalPositionFree = 0.99; // [no unit]
+confidenceIntervalToLegalPositionNotFree = 0.999; // [no unit]
+ballPlacementTolerance = 50; // [mm]
+
+kickOffSetupDuration = 45000; // [ms]
+kickOffDuration = 10000; // [ms]
+penaltyKickSetupDuration = 30000; // [ms]
+penaltyKickDuration = 30000; // [ms]
+freeKickDuration = 30000; // [ms]
+playingSignalDelay = 15000; // [ms]
+goalSignalDelay = 15000; // [ms]
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/logger.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/logger.cfg
new file mode 100644
index 0000000000..dbe4cc234c
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/logger.cfg
@@ -0,0 +1,123 @@
+// Is logging enabled?
+enabled = true;
+
+// The directory that will contain the log file.
+path = "/home/nao/logging";
+
+// The number of buffers allocated.
+numOfBuffers = 12000;
+
+// The size of each buffer in bytes.
+sizeOfBuffer = 200000;
+
+// The scheduling priority of the writer thread.
+writePriority = -2;
+
+// Logging will stop if less MB are available to the target device.
+minFreeDriveSpace = 100;
+
+// Representations to log per thread
+representationsPerThread = [
+  {
+    thread = Upper;
+    representations = [
+      JPEGImage,
+
+      BallPercept,
+      BallSpots,
+      BodyContour,
+      CameraInfo,
+      CameraMatrix,
+      CirclePercept,
+      FieldBoundary,
+      FrameInfo,
+      ImageCoordinateSystem,
+      LinesPercept,
+      ObstaclesFieldPercept,
+      ObstaclesImagePercept,
+      OdometryData,
+      PenaltyMarkPercept,
+    ];
+  },
+  {
+    thread = Lower;
+    representations = [
+      JPEGImage,
+
+      BallPercept,
+      BallSpots,
+      BodyContour,
+      CameraInfo,
+      CameraMatrix,
+      CirclePercept,
+      FieldBoundary,
+      FrameInfo,
+      ImageCoordinateSystem,
+      LinesPercept,
+      ObstaclesFieldPercept,
+      ObstaclesImagePercept,
+      OdometryData,
+      PenaltyMarkPercept,
+    ];
+  },
+  {
+    thread = Cognition;
+    representations = [
+      ActivationGraph,
+      AlternativeRobotPoseHypothesis,
+      ArmMotionRequest,
+      BallModel,
+      BehaviorStatus,
+      CameraCalibration,
+      GameState,
+      IMUCalibration,
+      MotionRequest,
+      ObstacleModel,
+      OdometryData,
+      ReceivedTeamMessages,
+      RobotHealth,
+      RobotPose,
+      SelfLocalizationHypotheses,
+      SideInformation,
+      SkillRequest,
+      StrategyStatus,
+      TeammatesBallModel,
+      TeamData,
+    ];
+  },
+  {
+    thread = Motion;
+    representations = [
+      FallDownState,
+      FootOffset,
+      FootSupport,
+      FrameInfo,
+      FsrData,
+      FsrSensorData,
+      GroundContactState,
+      GyroState,
+      InertialSensorData,
+      InertialData,
+      JointAnglePred,
+      JointCalibration,
+      JointPlay,
+      JointRequest,
+      JointSensorData,
+      KeyStates,
+      MotionInfo,
+      OdometryData,
+      OdometryDataPreview,
+      SystemSensorData,
+      RobotStableState,
+      WalkLearner,
+      WalkStepData,
+    ];
+  },
+  {
+    thread = Audio;
+    representations = [
+      AudioData,
+      FrameInfo,
+    ];
+  }
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/selfLocator.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/selfLocator.cfg
new file mode 100644
index 0000000000..56c23c21a1
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/selfLocator.cfg
@@ -0,0 +1,67 @@
+numberOfSamples = 12;
+
+defaultPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 500; y = 500;};
+    };
+walkInPoseDeviation = {
+      rotation = 12deg;
+      translation = {x = 500; y = 1000;};
+    };
+returnFromPenaltyPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 700; y = 200;};
+    };
+manualPlacementPoseDeviation = {
+      rotation = 17deg;
+      translation = {x = 500; y = 500;};
+    };
+penaltyShootoutPoseDeviation = {
+      rotation = 9deg;
+      translation = {x = 200; y = 200;};
+    };
+filterProcessDeviation = {
+      rotation = 0.002;
+      translation = {x = 2.0; y = 2.0;};
+    };
+odometryDeviation  = {
+      rotation = 0.3;
+      translation = {x = 0.2; y = 0.2;};
+    };
+odometryRotationDeviation  = {
+      x = 0.00157;
+      y = 0.00157;
+    };
+
+movedDistWeightRotationNoise = 0.0005;
+movedAngleWeightRotationNoise = 0.25;
+movedAngleWeightRotationNoiseNotWalking = 0.075;
+majorDirTransWeight = 2;
+minorDirTransWeight = 1;
+
+minValidityForSuperbLocalizationQuality = 0.8;
+maxTranslationDeviationForSuperbLocalizationQuality = 100.0;
+maxRotationalDeviationForSuperbLocalizationQuality = 10deg;
+baseValidityWeighting = 0.1;
+numberOfConsideredFramesForValidity  = 60;
+considerLinesForValidityComputation = true;
+validityFactorPoseMeasurement = 5;
+validityFactorLandmarkMeasurement = 3;
+validityFactorLineMeasurement = 1;
+
+positionJumpNotificationDistance = 2000.0;
+
+minNumberOfObservationsForResetting = 6;
+translationalDeviationForResetting = 1500.0;
+rotationalDeviationForResetting = 0.5;
+returnFromPenaltyMaxXOffset = 250.0;
+
+demoUseCustomReturnFromPenaltyPoses = false;
+demoCustomReturnFromPenaltyPoseGoalie = {
+      rotation = 0deg;
+      translation = {x = -2000.0; y = 0.0;};
+    };
+demoCustomReturnFromPenaltyPoseFieldPlayer = {
+      rotation = 0deg;
+      translation = {x = -750.0; y = 0.0;};
+    };
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/setupPosesProvider.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/setupPosesProvider.cfg
new file mode 100644
index 0000000000..20a307c37f
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/setupPosesProvider.cfg
@@ -0,0 +1,25 @@
+// Positions as defined in the latest version of the rule book:
+// DEFENDERS ONLY:
+// - goalkeeper on the goal line between the two goal posts;
+// - front line of penalty area;
+// - within center circle;
+poses = [
+  // Note: The SetupPosesProvider will randomize these setup positions within the player's corresponding area as defined in the challenge rules.
+  {
+    playerNumber = 1;                     /*< The player number of the robot */
+    position = {x = -4500; y = 0;};       /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = 0;};      /*< The position (in global field coordinates) at which the robot is turned */
+  },
+  {
+    playerNumber = 2;                     /*< The player number of the robot */
+    position = {x = -2850; y = -1000;};       /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = -1000;};      /*< The position (in global field coordinates) at which the robot is turned */
+  },
+  {
+    playerNumber = 3;                     /*< The player number of the robot */
+    position = {x = -375; y = 0;};           /*< The position (in global field coordinates) at which the robot is placed */
+    turnedTowards = {x = 0; y = 0;};   /*< The position (in global field coordinates) at which the robot is turned */
+  },
+ // Other player numbers are not defined here. In case a robot is deployed with number 4 - 7,
+ // an assert will terminate the software :-)
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/skillBehaviorControl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/skillBehaviorControl.cfg
new file mode 100644
index 0000000000..b9ca41dc75
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/skillBehaviorControl.cfg
@@ -0,0 +1,18 @@
+options = [
+  HandlePhysicalRobot,
+  HandlePlayerState,
+  HandleGameState,
+];
+
+playingOptions = [
+  HandleGoalkeeperCatchBall,
+  HandleStrikerLostBall,
+  HandleCatchBall,
+];
+
+useNewHandleCatchBallBehavior = false;
+
+// Referee Challenge options
+refereeXRange = {min = -1000; max = 800;};
+refereeYRange = {min = 0; max = 1900;};
+refereeDuration = 10000;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/strategyBehaviorControl.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/strategyBehaviorControl.cfg
new file mode 100644
index 0000000000..47db364ce4
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/strategyBehaviorControl.cfg
@@ -0,0 +1 @@
+strategy = dbhc;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/teamMessage.def b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/teamMessage.def
new file mode 100644
index 0000000000..e7f04b30c0
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/teamMessage.def
@@ -0,0 +1,92 @@
+RobotPoseCompact
+{
+  rotation: Angle(bits=8)
+  translation: Vector<Float(min=-5120, max=5110, bits=10)>(n=2)
+  quality: Enum(type=RobotPose::LocalizationQuality)
+  covariance: Matrix<Integer(min=-32768, max=32767)>(m=2, n=2, symmetric) // Is actually something like Matrix<float16_t>
+  timestampLastJump: Timestamp(bits=1, shift=10, reference=relativePast, noclip)
+}
+
+RobotStatus
+{
+  isUpright: Boolean
+  timeWhenLastUpright: Timestamp(bits=8, shift=6, reference=relativePast)
+}
+
+BallState
+{
+  position: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)
+  velocity: Vector<Float(min=-8000, max=8000, bits=11)>(n=2)
+  // covariance: Matrix<Float>(m=2, n=2, symmetric) // Unused
+}
+
+BallModel
+{
+  // lastPerception: Vector<Float(min=-32768, max=32767, bits=16)>(n=2) // Unused
+  estimate: BallState
+  timeWhenDisappeared: Timestamp(bits=9, shift=6, reference=relativePast, noclip)
+  timeWhenLastSeen: Timestamp(bits=11, shift=4, reference=relativePast, noclip)
+  // seenPercentage: Integer(min=0, max=100) // Unused
+}
+
+RecentWhistle
+{
+  confidenceOfLastWhistleDetection: Float(min=0, max=2.55, bits=8)
+  lastTimeWhistleDetected: Timestamp(bits=8, shift=4, reference=relativePast, noclip)
+}
+
+WhistleCompact
+{
+  listening: Boolean
+  recentWhistle: RecentWhistle[:1]
+}
+
+BehaviorStatus
+{
+  passTarget: Integer(min=-1, max=14)
+  walkingTo: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)
+  speed: Float(min=0.0, max=310.0, bits=5)
+  shootingTo: Vector<Float(min=-12800, max=12800, bits=11)>(n=2)[:1]
+  lastKickTimestamp: Timestamp
+}
+
+StrategyStatus
+{
+  proposedTactic: Enum(type=Tactic::Type)
+  acceptedTactic: Enum(type=Tactic::Type)
+  proposedMirror: Boolean
+  acceptedMirror: Boolean
+  proposedSetPlay: Enum(type=SetPlay::Type)
+  acceptedSetPlay: Enum(type=SetPlay::Type)
+  position: Enum(type=Tactic::Position::Type)
+  role: Enum(type=Role::Type)
+}
+
+Obstacle
+{
+  center: Vector<Float(min=-32768, max=32767, bits=16)>(n=2)
+  lastSeen: Timestamp(bits=8, shift=6, reference=relativePast)
+  type: Enum(type=Obstacle::Type)
+}
+
+ObstacleModel
+{
+  obstacles: Obstacle[:3]
+}
+
+FrameInfo
+{
+  time: Timestamp(bits=0, reference=relativePast)
+}
+
+TeamMessage
+{
+  theRobotPose: RobotPoseCompact
+  theRobotStatus: RobotStatus
+  theFrameInfo: FrameInfo
+  theBallModel: BallModel
+  theWhistle: WhistleCompact
+  theBehaviorStatus: BehaviorStatus
+  theStrategyStatus: StrategyStatus
+  theObstacleModel: ObstacleModel
+}
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/teamMessageHandler.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/teamMessageHandler.cfg
new file mode 100644
index 0000000000..77aedcc8b2
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/teamMessageHandler.cfg
@@ -0,0 +1,19 @@
+minSendInterval = 650;
+durationOfHalf = 240000;
+overallMessageBudget = 1200;
+normalMessageReserve = 20;
+priorityMessageReserve = 10;
+lookahead = 5000;
+positionThreshold = 200;
+bearingThreshold = 3deg;
+assumedObservationHeight = 450;
+teamBallThresholdBase = 9000;
+teamBallThresholdFactor = 500;
+newBallThreshold = 500;
+disappearedThreshold = 3000;
+ignoreWhistleBeforeEndOfHalf = 5000;
+maxWhistleSendDelay = 4000;
+minTimeBetween2RejectSounds = 5000;
+sendMirroredRobotPose = false;
+dropUnsynchronizedMessages = true;
+alwaysSend = true;
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/threads.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/threads.cfg
new file mode 100644
index 0000000000..dd9cc8a9b7
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/threads.cfg
@@ -0,0 +1,301 @@
+defaultRepresentations = [
+  CalibrationGenerator,
+  GroundTruthRobotPose,
+  RefereePercept,
+  ReplayWalkRequestGenerator,
+  Whistle,
+];
+threads = [
+  {
+    name = Upper;
+    priority = 0;
+    debugReceiverSize = 2800000;
+    debugSenderSize = 5200000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Perception;
+    representationProviders = [
+      {representation = OtherFieldBoundary; provider = LowerProvider;},
+      {representation = OtherObstaclesPerceptorData; provider = LowerProvider;},
+      {representation = OtherOdometryData; provider = LowerProvider;},
+
+      {representation = AutoExposureWeightTable; provider = AutoExposureWeightTableProvider;},
+      {representation = BallPercept; provider = BallPerceptor;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BallSpots; provider = BallSpotsProvider;},
+      {representation = BodyContour; provider = BodyContourProvider;},
+      {representation = CameraImage; provider = CameraProvider;},
+      {representation = CameraInfo; provider = CameraProvider;},
+      {representation = CameraIntrinsics; provider = CameraProvider;},
+      {representation = CameraMatrix; provider = CameraMatrixProvider;},
+      {representation = CameraSettings; provider = ConfigurationDataProvider;},
+      {representation = CameraStatus; provider = CameraProvider;},
+      {representation = CirclePercept; provider = LinePerceptor;},
+      {representation = ColorScanLineRegionsHorizontal; provider = ScanLineRegionizer;},
+      {representation = ColorScanLineRegionsVerticalClipped; provider = ScanLineRegionizer;},
+      {representation = ECImage; provider = ECImageProvider;},
+      {representation = FieldBoundary; provider = FieldBoundaryProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldLineIntersections; provider = FieldLinesProvider;},
+      {representation = FieldLines; provider = FieldLinesProvider;},
+      {representation = FrameInfo; provider = CameraProvider;},
+      {representation = ImageCoordinateSystem; provider = CoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = IntersectionsProvider;},
+      {representation = JerseyClassifier; provider = JerseyClassifierProvider2020For2023;},
+      {representation = JPEGImage; provider = CameraProvider;},
+      {representation = LinesPercept; provider = LinePerceptor;},
+      {representation = MeasurementCovariance; provider = LegacyMeasurementCovarianceProvider;},
+      {representation = ObstaclesFieldPercept; provider = RobotDetector;},
+      {representation = ObstaclesImagePercept; provider = RobotDetector;},
+      {representation = ObstaclesPerceptorData; provider = RobotDetector;},
+      {representation = OdometryData; provider = ImageFrameProvider;},
+      {representation = OptionalECImage; provider = ECImageProvider;},
+      {representation = OptionalCameraImage; provider = OptionalCameraImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PenaltyMarkPerceptor;},
+      {representation = PenaltyMarkRegions; provider = PenaltyMarkRegionsProvider;},
+      {representation = RelativeFieldColors; provider = RelativeFieldColorsProvider;},
+      {representation = RelativeFieldColorsParameters; provider = ConfigurationDataProvider;},
+      {representation = RobotCameraMatrix; provider = RobotCameraMatrixProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = ScanGrid; provider = ScanGridProvider;},
+    ];
+  }, {
+    name = Lower;
+    priority = 0;
+    debugReceiverSize = 1000000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Perception;
+    representationProviders = [
+      {representation = OtherFieldBoundary; provider = UpperProvider;},
+      {representation = OtherObstaclesPerceptorData; provider = UpperProvider;},
+      {representation = OtherOdometryData; provider = UpperProvider;},
+
+      {representation = AutoExposureWeightTable; provider = AutoExposureWeightTableProvider;},
+      {representation = BallPercept; provider = BallPerceptor;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BallSpots; provider = BOPPerceptor;},
+      {representation = BodyContour; provider = BodyContourProvider;},
+      {representation = CameraImage; provider = CameraProvider;},
+      {representation = CameraInfo; provider = CameraProvider;},
+      {representation = CameraIntrinsics; provider = CameraProvider;},
+      {representation = CameraMatrix; provider = CameraMatrixProvider;},
+      {representation = CameraSettings; provider = ConfigurationDataProvider;},
+      {representation = CameraStatus; provider = CameraProvider;},
+      {representation = CirclePercept; provider = LinePerceptor;},
+      {representation = ColorScanLineRegionsHorizontal; provider = ScanLineRegionizer;},
+      {representation = ColorScanLineRegionsVerticalClipped; provider = ScanLineRegionizer;},
+      {representation = ECImage; provider = ECImageProvider;},
+      {representation = FieldBoundary; provider = FieldBoundaryProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldLineIntersections; provider = FieldLinesProvider;},
+      {representation = FieldLines; provider = FieldLinesProvider;},
+      {representation = FrameInfo; provider = CameraProvider;},
+      {representation = ImageCoordinateSystem; provider = CoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = IntersectionsProvider;},
+      {representation = JerseyClassifier; provider = JerseyClassifierProvider2020For2023;},
+      {representation = JPEGImage; provider = CameraProvider;},
+      {representation = LinesPercept; provider = LinePerceptor;},
+      {representation = MeasurementCovariance; provider = LegacyMeasurementCovarianceProvider;},
+      {representation = ObstaclesFieldPercept; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = ObstaclesImagePercept; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = ObstaclesPerceptorData; provider = PlayersDeeptectorFeatBOPLower;},
+      {representation = OdometryData; provider = ImageFrameProvider;},
+      {representation = OptionalECImage; provider = ECImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PenaltyMarkPerceptor;},
+      {representation = PenaltyMarkRegions; provider = BOPPerceptor;},
+      {representation = RelativeFieldColors; provider = RelativeFieldColorsProvider;},
+      {representation = RelativeFieldColorsParameters; provider = ConfigurationDataProvider;},
+      {representation = RobotCameraMatrix; provider = RobotCameraMatrixProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = ScanGrid; provider = ScanGridProvider;},
+      {representation = SegmentedObstacleImage; provider = BOPPerceptor;},
+    ];
+  }, {
+    name = Cognition;
+    priority = 1;
+    debugReceiverSize = 2000000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 200000;
+    executionUnit = Cognition;
+    representationProviders = [
+      {representation = BallPercept; provider = PerceptionBallPerceptProvider;},
+      {representation = BodyContour; provider = PerceptionBodyContourProvider;},
+      {representation = CameraInfo; provider = PerceptionCameraInfoProvider;},
+      {representation = CameraMatrix; provider = PerceptionCameraMatrixProvider;},
+      {representation = CameraStatus; provider = PerceptionCameraStatusProvider;},
+      {representation = CenterCircleWithLine; provider = CenterCircleWithLinePerceptor;},
+      {representation = CirclePercept; provider = PerceptionCirclePerceptProvider;},
+      {representation = FieldBoundary; provider = PerceptionFieldBoundaryProvider;},
+      {representation = FieldLines; provider = PerceptionFieldLinesProvider;},
+      {representation = FieldLineIntersections; provider = PerceptionFieldLineIntersectionsProvider;},
+      {representation = FrameInfo; provider = PerceptionFrameInfoProvider;},
+      {representation = ImageCoordinateSystem; provider = PerceptionImageCoordinateSystemProvider;},
+      {representation = IntersectionsPercept; provider = PerceptionIntersectionsPerceptProvider;},
+      {representation = LinesPercept; provider = PerceptionLinesPerceptProvider;},
+      {representation = ObstaclesFieldPercept; provider = PerceptionObstaclesFieldPerceptProvider;},
+      {representation = OdometryData; provider = MotionProvider;},
+      {representation = OptionalECImage; provider = PerceptionOptionalECImageProvider;},
+      {representation = PenaltyMarkPercept; provider = PerceptionPenaltyMarkPerceptProvider;},
+      {representation = RobotCameraMatrix; provider = PerceptionRobotCameraMatrixProvider;},
+
+      {representation = ActivationGraph; provider = SkillBehaviorControl;},
+      {representation = AlternativeRobotPoseHypothesis; provider = AlternativeRobotPoseProvider;},
+      {representation = ArmMotionRequest; provider = SkillBehaviorControl;},
+      {representation = BallContactChecker; provider = BallContactCheckerProvider;},
+      {representation = BallDropInModel; provider = BallDropInLocator;},
+      {representation = BallInGoal; provider = BallInGoalTracker;},
+      {representation = BallModel; provider = BallStateEstimator;},
+      {representation = BallSearchAreas; provider = BallSearchAreasProvider;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = BehaviorParameters; provider = ConfigurationDataProvider;},
+      {representation = BehaviorStatus; provider = SkillBehaviorControl;},
+      {representation = BHumanMessageOutputGenerator; provider = TeamMessageHandler;},
+      {representation = CameraCalibration; provider = AutomaticCameraCalibrator;},
+      {representation = CalibrationRequest; provider = SkillBehaviorControl;},
+      {representation = CameraCalibrationStatus; provider = AutomaticCameraCalibrator;},
+      {representation = CameraResolutionRequest; provider = AutomaticCameraCalibrator;},
+      {representation = DamageConfigurationBody; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = EnhancedKeyStates; provider = KeyStateEnhancer;},
+      {representation = ExpectedGoals; provider = ExpectedGoalsProvider;},
+      {representation = ExecutedPasses; provider = ExecutedPassesProvider;},
+      {representation = ExtendedGameState; provider = ExtendedGameStateProvider;},
+      {representation = FieldBall; provider = FieldBallProvider;},
+      {representation = FieldDimensions; provider = ConfigurationDataProvider;},
+      {representation = FieldFeatureOverview; provider = FieldFeatureOverviewProvider;},
+      {representation = FieldRating; provider = FieldRatingProvider;},
+      {representation = FilteredBallPercepts; provider = BallPerceptFilter;},
+      {representation = GameControllerData; provider = GameControllerDataProvider;},
+      {representation = GameState; provider = GameStateProvider;},
+      {representation = GlobalOpponentsModel; provider = GlobalOpponentsTracker;},
+      {representation = GlobalTeammatesModel; provider = GlobalTeammatesTracker;},
+      {representation = GoaliePose; provider = GoaliePoseProvider;},
+      {representation = HeadLimits; provider = ConfigurationDataProvider;},
+      {representation = HeadMotionRequest; provider = SkillBehaviorControl;},
+      {representation = IllegalAreas; provider = IllegalAreaProvider;},
+      {representation = IMUCalibration; provider = IMUCalibrationProvider;},
+      {representation = JointLimits; provider = ConfigurationDataProvider;},
+      {representation = KickInfo; provider = ConfigurationDataProvider;},
+      {representation = LEDRequest; provider = LEDHandler;},
+      {representation = LibCheck; provider = LibCheckProvider;},
+      {representation = LibDemo; provider = LibDemoProvider;},
+      {representation = LibLookActive; provider = LibLookActiveProvider;},
+      {representation = LibPosition; provider = LibPositionProvider;},
+      {representation = LibTeammates; provider = LibTeammatesProvider;},
+      {representation = LibWalk; provider = LibWalkProvider;},
+      {representation = MotionRequest; provider = SkillBehaviorControl;},
+      {representation = ObstacleModel; provider = ObstacleModelProvider;},
+      {representation = Odometer; provider = OdometerProvider;},
+      {representation = OptionalImageRequest; provider = SkillBehaviorControl;},
+      {representation = PassEvaluation; provider = PassEvaluationProvider;},
+      {representation = PathPlanner; provider = PathPlannerProvider;},
+      {representation = PenaltyMarkWithPenaltyAreaLine; provider = PenaltyMarkWithPenaltyAreaLinePerceptor;},
+      {representation = PerceptRegistration; provider = PerceptRegistrationProvider;},
+      {representation = ReceivedTeamMessages; provider = TeamMessageHandler;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = RobotHealth; provider = RobotHealthProvider;},
+      {representation = RobotPose; provider = SelfLocator;},
+      {representation = SelfLocalizationHypotheses; provider = SelfLocator;},
+      {representation = SentTeamMessage; provider = TeamMessageHandler;},
+      {representation = SetupPoses; provider = SetupPosesProvider;},
+      {representation = SideInformation; provider = SideInformationProvider;},
+      {representation = SkillRequest; provider = StrategyBehaviorControlDBHDortmund;},
+      {representation = StaticInitialPose; provider = StaticInitialPoseProvider;},
+      {representation = StrategyStatus; provider = StrategyBehaviorControl;},
+      {representation = TeammatesBallModel; provider = TeammatesBallModelProvider;},
+      {representation = TeamData; provider = TeamDataProvider;},
+      {representation = WorldModelPrediction; provider = WorldModelPredictor;},
+    ];
+  },{
+    name = Motion;
+    priority = 20;
+    debugReceiverSize = 500000;
+    debugSenderSize = 130000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Motion;
+    representationProviders = [
+      {representation = ArmContactModel; provider = ArmContactModelProvider;},
+      {representation = ArmKeyFrameGenerator; provider = ArmKeyFrameEngine;},
+      {representation = ArmMotionInfo; provider = MotionEngine;},
+      {representation = BallSpecification; provider = ConfigurationDataProvider;},
+      {representation = CameraIntrinsics; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationBody; provider = ConfigurationDataProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = DiveGenerator; provider = KeyframeMotionEngine;},
+      {representation = DribbleGenerator; provider = DribbleEngine;},
+      {representation = EnergySaving; provider = EnergySavingProvider;},
+      {representation = FallDownState; provider = FallDownStateProvider;},
+      {representation = FallGenerator; provider = FallEngine;},
+      {representation = FilteredCurrent; provider = FilteredCurrentProvider;},
+      {representation = FootBumperState; provider = FootBumperStateProvider;},
+      {representation = FootSupport; provider = FootSupportProvider;},
+      {representation = FootOffset; provider = ConfigurationDataProvider;},
+      {representation = FrameInfo; provider = NaoProvider;},
+      {representation = FsrData; provider = FsrDataProvider;},
+      {representation = FsrSensorData; provider = NaoProvider;},
+      {representation = GetUpGenerator; provider = KeyframeMotionEngine;},
+      {representation = GroundContactState; provider = GroundContactDetector;},
+      {representation = GyroOffset; provider = GyroOffsetProvider;},
+      {representation = GyroState; provider = GyroStateProvider;},
+      {representation = HeadLimits; provider = ConfigurationDataProvider;},
+      {representation = HeadMotionGenerator; provider = HeadMotionEngine;},
+      {representation = HeadMotionInfo; provider = MotionEngine;},
+      {representation = InertialData; provider = InertialDataProvider;},
+      {representation = InertialSensorData; provider = NaoProvider;},
+      {representation = InterceptBallGenerator; provider = InterceptBallProvider;},
+      {representation = JointAnglePred; provider = JointAnglePredictor;},
+      {representation = JointAngles; provider = JointAnglesProvider;},
+      {representation = JointCalibration; provider = ConfigurationDataProvider;},
+      {representation = JointLimits; provider = ConfigurationDataProvider;},
+      {representation = JointPlay; provider = JointPlayProvider;},
+      {representation = JointPlayTranslation; provider = JointPlayTranslationProvider;},
+      {representation = JointRequest; provider = MotionEngine;},
+      {representation = JointSensorData; provider = NaoProvider;},
+      {representation = KeyframeMotionGenerator; provider = KeyframeMotionEngine;},
+      {representation = KeyframeMotionParameters; provider = ConfigurationDataProvider;},
+      {representation = KeyStates; provider = NaoProvider;},
+      {representation = KickGenerator; provider = KickEngine;},
+      {representation = KickInfo; provider = ConfigurationDataProvider;},
+      {representation = MassCalibration; provider = ConfigurationDataProvider;},
+      {representation = MotionInfo; provider = MotionEngine;},
+      {representation = MotionRobotHealth; provider = MotionRobotHealthProvider;},
+      {representation = OdometryData; provider = MotionEngine;},
+      {representation = OdometryDataPreview; provider = OdometryDataPreviewProvider;},
+      {representation = OdometryTranslationRequest; provider = OdometryDataPreviewProvider;},
+      {representation = PointAtGenerator; provider = PointAtEngine;},
+//      {representation = ReplayWalkRequestGenerator; provider = ReplayWalkRequestProvider;},
+      {representation = RobotDimensions; provider = ConfigurationDataProvider;},
+      {representation = RobotModel; provider = RobotModelProvider;},
+      {representation = RobotStableState; provider = RobotStableStateProvider;},
+      {representation = SpecialGenerator; provider = KeyframeMotionEngine;},
+      {representation = StandGenerator; provider = WalkingEngine;},
+      {representation = StaticJointPoses; provider = ConfigurationDataProvider;},
+      {representation = StiffnessSettings; provider = ConfigurationDataProvider;},
+      {representation = SystemSensorData; provider = NaoProvider;},
+      {representation = TorsoMatrix; provider = TorsoMatrixProvider;},
+      {representation = WalkAtAbsoluteSpeedGenerator; provider = WalkAtSpeedEngine;},
+      {representation = WalkAtRelativeSpeedGenerator; provider = WalkAtSpeedEngine;},
+      {representation = WalkGenerator; provider = WalkingEngine;},
+      {representation = WalkingEngineOutput; provider = WalkingEngine;},
+      {representation = WalkKickGenerator; provider = WalkKickEngine;},
+      {representation = WalkLearner; provider = WalkLearnerProvider;},
+      {representation = WalkModifier; provider = ConfigurationDataProvider;},
+      {representation = WalkStepData; provider = WalkingEngine;},
+      {representation = WalkToBallGenerator; provider = WalkToBallEngine;},
+      {representation = WalkToBallAndKickGenerator; provider = WalkToBallAndKickEngine;},
+      {representation = WalkToPoseGenerator; provider = WalkToPoseEngine;},
+    ];
+  },{
+    name = Audio;
+    priority = 0;
+    debugReceiverSize = 500000;
+    debugSenderSize = 2000000;
+    debugSenderInfrastructureSize = 100000;
+    executionUnit = Audio;
+    representationProviders = [
+      {representation = AudioData; provider = AudioProvider;},
+      {representation = DamageConfigurationHead; provider = ConfigurationDataProvider;},
+      {representation = FrameInfo; provider = AudioProvider;},
+    ];
+  },
+];
diff --git a/Config/Scenarios/DynamicBallHandlingChallengeDortmund/walkingEngine.cfg b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/walkingEngine.cfg
new file mode 100644
index 0000000000..d03cfb1661
--- /dev/null
+++ b/Config/Scenarios/DynamicBallHandlingChallengeDortmund/walkingEngine.cfg
@@ -0,0 +1,27 @@
+configuratedParameters = {
+  maxSpeed = { // translation reduced by *0.66 due to speed limit in challenge
+    rotation = 120deg;
+    translation = {x = 166; y = 166;};
+  };
+  minSpeed = {
+    rotation = 90deg;
+    translation = {x = 150; y = 150;};
+  };
+  maxSpeedBackwards = 150;
+  minSpeedBackwards = 125;
+  maxGyroBalanceKneeValue = 2deg;
+  emergencyNotMovingTime = 1000;
+  thresholdStopStandTransition = { rotation = 2deg; translation = { x = 5; y = 0.175; }; };
+  supportSwitchPhaseRange = { min = 0.5; max = 10; };
+  jointPlayOffsetParameters = {
+    applyOffsetFactor = 0.5;
+    applyOffsetFactorAnkle = 0.5;
+  };
+  walkSpeedParams = {
+    maxSpeed = {
+      rotation = 120deg;
+      translation = {x = 350; y = 300;};
+    };
+    maxSpeedBackwards = 250;
+  };
+};
diff --git a/Config/Scenes/Drawings/PassToTeammate.con b/Config/Scenes/Drawings/PassToTeammate.con
index f3e5967353..2b279cfa9c 100644
--- a/Config/Scenes/Drawings/PassToTeammate.con
+++ b/Config/Scenes/Drawings/PassToTeammate.con
@@ -1,4 +1,4 @@
-call Includes/Views
+#call Includes/Views
 vfd worldState skill:PassToTeammate:target
 echo vfd worldState skill:PassToTeammate:target
 echo vfd worldState skill:PassToTeammate:evaluation
diff --git a/Config/Scenes/Includes/GameStates.con b/Config/Scenes/Includes/GameStates.con
index 47f2b0af9a..605ce9fa68 100644
--- a/Config/Scenes/Includes/GameStates.con
+++ b/Config/Scenes/Includes/GameStates.con
@@ -1,5 +1,5 @@
 # Simulator provides whistle
-mr Whistle LogDataProvider
+#mr Whistle LogDataProvider
 
 # Everything else is the same in 2D
 call Includes/GameStates2D
diff --git a/Config/Scenes/OtherScenes/DynamicBallHandlingAttacker.con b/Config/Scenes/OtherScenes/DynamicBallHandlingAttacker.con
new file mode 100644
index 0000000000..0fb7e757e5
--- /dev/null
+++ b/Config/Scenes/OtherScenes/DynamicBallHandlingAttacker.con
@@ -0,0 +1,17 @@
+call Includes/PerceptOracle
+
+dr representation:SetupPoses:place
+
+gc set
+ar off
+
+
+robot robot1 robot2 robot3
+mr Whistle LogDataProvider
+call Drawings/PassToTeammate
+vfd worldState representation:GlobalTeammatesModel
+set parameters:WalkingEngine configuratedParameters = { maxSpeed = { rotation = 120deg; translation = { x = 166; y = 166; }; }; minSpeed = { rotation = 120deg; translation = { x = 166; y = 166; }; }; maxSpeedBackwards = 150; minSpeedBackwards = 125; emergencyNotMovingTime = 100; maxGyroBalanceKneeValue = 0.5deg; supportSwitchPhaseRange = { min = 0.5; max = 6; }; thresholdStopStandTransition = { rotation = 2deg; translation = { x = 10; y = 0.175; }; }; walkSpeedParams = { maxSpeed = { rotation = 120deg; translation = { x = 350; y = 270; }; }; maxSpeedBackwards = 250; }; jointPlayOffsetParameters = { applyOffsetFactor = 0.1; applyOffsetFactorAnkle = 0.1; }; };
+robot robot21 robot22 robot23
+
+dr module:WalkingEngine:init:parameters
+robot all
diff --git a/Config/Scenes/OtherScenes/DynamicBallHandlingAttacker.ros2 b/Config/Scenes/OtherScenes/DynamicBallHandlingAttacker.ros2
new file mode 100644
index 0000000000..56adea5c64
--- /dev/null
+++ b/Config/Scenes/OtherScenes/DynamicBallHandlingAttacker.ros2
@@ -0,0 +1,71 @@
+<Simulation>
+
+  <Include href="../Includes/NaoV6H25.rsi2"/>
+  <Include href="../Includes/Ball2016SPL.rsi2"/>
+  <Include href="../Includes/Field2020SPL.rsi2"/>
+
+  <Scene name="RoboCup" controller="SimulatedNao" stepLength="0.012" color="rgb(65%, 65%, 70%)" ERP="0.8" CFM="0.001" contactSoftERP="0.2" contactSoftCFM="0.005">
+    <PointLight z="9m" ambientColor="rgb(50%, 50%, 50%)"/>
+
+    <Compound name="teams">
+      <Compound name="B-Human">
+        <Compound name="5"/>
+        <Compound name="black"/>
+        <Compound name="purple"/>
+      </Compound>
+      <Compound name="B-Team">
+        <Compound name="70"/>
+        <Compound name="red"/>
+        <Compound name="blue"/>
+      </Compound>
+    </Compound>
+
+    <Compound name="robots">
+      <Body ref="Nao" name="robot1">
+        <Translation x="3.9m" y="0" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="purple"/>
+      </Body>
+      <Body ref="Nao" name="robot2">
+        <Translation x="0.485m" y="-2.235m" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="black"/>
+      </Body>
+      <Body ref="Nao" name="robot3">
+        <Translation x="0.485m" y="2.235m" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="black"/>
+      </Body>
+      <Body ref="Nao" name="robot21">
+        <Translation x="-4.5m" y="0" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="blue"/>
+      </Body>
+      <Body ref="Nao" name="robot22">
+        <Translation x="-2.850m" y="-1m" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="red"/>
+      </Body>
+      <Body ref="Nao" name="robot23">
+        <Translation x="-0.375m" y="0" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="red"/>
+      </Body>
+    </Compound>
+
+    <Compound name="extras"/>
+
+    <Compound name="balls">
+      <Body ref="ball">
+        <Translation x="3.2m" y="0" z="1m"/>
+      </Body>
+    </Compound>
+
+    <Compound ref="field"/>
+
+    <Compound name="scenarios">
+      <Compound name="DynamicBallHandlingChallengeAttacker"/>
+      <Compound name="DynamicBallHandlingChallengeDefender"/>
+    </Compound>
+  </Scene>
+</Simulation>
diff --git a/Config/Scenes/OtherScenes/DynamicBallHandlingAttackerDortmund.con b/Config/Scenes/OtherScenes/DynamicBallHandlingAttackerDortmund.con
new file mode 100644
index 0000000000..25c3b50062
--- /dev/null
+++ b/Config/Scenes/OtherScenes/DynamicBallHandlingAttackerDortmund.con
@@ -0,0 +1,14 @@
+call Includes/PerceptOracle
+
+dr representation:SetupPoses:place
+
+gc set
+ar off
+
+call Drawings/PassToTeammate
+vfd worldState representation:GlobalTeammatesModel
+
+robot robot21 robot22 robot23
+set parameters:WalkingEngine configuratedParameters = { maxSpeed = { rotation = 120deg; translation = { x = 166; y = 166; }; }; minSpeed = { rotation = 120deg; translation = { x = 166; y = 166; }; }; maxSpeedBackwards = 150; minSpeedBackwards = 125; emergencyNotMovingTime = 100; maxGyroBalanceKneeValue = 0.5deg; supportSwitchPhaseRange = { min = 0.5; max = 6; }; thresholdStopStandTransition = { rotation = 2deg; translation = { x = 10; y = 0.175; }; }; walkSpeedParams = { maxSpeed = { rotation = 120deg; translation = { x = 350; y = 270; }; }; maxSpeedBackwards = 250; }; jointPlayOffsetParameters = { applyOffsetFactor = 0.1; applyOffsetFactorAnkle = 0.1; }; };
+dr module:WalkingEngine:init:parameters
+robot all
diff --git a/Config/Scenes/OtherScenes/DynamicBallHandlingAttackerDortmund.ros2 b/Config/Scenes/OtherScenes/DynamicBallHandlingAttackerDortmund.ros2
new file mode 100644
index 0000000000..8d74594233
--- /dev/null
+++ b/Config/Scenes/OtherScenes/DynamicBallHandlingAttackerDortmund.ros2
@@ -0,0 +1,71 @@
+<Simulation>
+
+  <Include href="../Includes/NaoV6H25.rsi2"/>
+  <Include href="../Includes/Ball2016SPL.rsi2"/>
+  <Include href="../Includes/Field2020SPL.rsi2"/>
+
+  <Scene name="RoboCup" controller="SimulatedNao" stepLength="0.012" color="rgb(65%, 65%, 70%)" ERP="0.8" CFM="0.001" contactSoftERP="0.2" contactSoftCFM="0.005">
+    <PointLight z="9m" ambientColor="rgb(50%, 50%, 50%)"/>
+
+    <Compound name="teams">
+      <Compound name="B-Human">
+        <Compound name="5"/>
+        <Compound name="black"/>
+        <Compound name="purple"/>
+      </Compound>
+      <Compound name="B-Team">
+        <Compound name="70"/>
+        <Compound name="red"/>
+        <Compound name="blue"/>
+      </Compound>
+    </Compound>
+
+    <Compound name="robots">
+      <Body ref="Nao" name="robot1">
+        <Translation x="3.9m" y="0" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="purple"/>
+      </Body>
+      <Body ref="Nao" name="robot2">
+        <Translation x="0.485m" y="-2.235m" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="black"/>
+      </Body>
+      <Body ref="Nao" name="robot3">
+        <Translation x="0.485m" y="2.235m" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="black"/>
+      </Body>
+      <Body ref="Nao" name="robot21">
+        <Translation x="-4.5m" y="0" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="blue"/>
+      </Body>
+      <Body ref="Nao" name="robot22">
+        <Translation x="-2.850m" y="-1m" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="red"/>
+      </Body>
+      <Body ref="Nao" name="robot23">
+        <Translation x="-0.375m" y="0" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="red"/>
+      </Body>
+    </Compound>
+
+    <Compound name="extras"/>
+
+    <Compound name="balls">
+      <Body ref="ball">
+        <Translation x="3.2m" y="0" z="1m"/>
+      </Body>
+    </Compound>
+
+    <Compound ref="field"/>
+
+    <Compound name="scenarios">
+      <Compound name="DynamicBallHandlingChallengeAttacker"/>
+      <Compound name="DynamicBallHandlingChallengeDortmund"/>
+    </Compound>
+  </Scene>
+</Simulation>
diff --git a/Config/Scenes/OtherScenes/DynamicBallHandlingDefender.con b/Config/Scenes/OtherScenes/DynamicBallHandlingDefender.con
new file mode 100644
index 0000000000..aa52e64bec
--- /dev/null
+++ b/Config/Scenes/OtherScenes/DynamicBallHandlingDefender.con
@@ -0,0 +1,6 @@
+call Includes/PerceptOracle
+
+dr representation:SetupPoses:place
+
+gc set
+ar off
diff --git a/Config/Scenes/OtherScenes/DynamicBallHandlingDefender.ros2 b/Config/Scenes/OtherScenes/DynamicBallHandlingDefender.ros2
new file mode 100644
index 0000000000..eaacbb1090
--- /dev/null
+++ b/Config/Scenes/OtherScenes/DynamicBallHandlingDefender.ros2
@@ -0,0 +1,71 @@
+<Simulation>
+
+  <Include href="../Includes/NaoV6H25.rsi2"/>
+  <Include href="../Includes/Ball2016SPL.rsi2"/>
+  <Include href="../Includes/Field2020SPL.rsi2"/>
+
+  <Scene name="RoboCup" controller="SimulatedNao" stepLength="0.012" color="rgb(65%, 65%, 70%)" ERP="0.8" CFM="0.001" contactSoftERP="0.2" contactSoftCFM="0.005">
+    <PointLight z="9m" ambientColor="rgb(50%, 50%, 50%)"/>
+
+    <Compound name="teams">
+      <Compound name="B-Human">
+        <Compound name="5"/>
+        <Compound name="black"/>
+        <Compound name="purple"/>
+      </Compound>
+      <Compound name="B-Team">
+        <Compound name="70"/>
+        <Compound name="red"/>
+        <Compound name="blue"/>
+      </Compound>
+    </Compound>
+
+    <Compound name="extras">
+      <Body ref="NaoDummy" name="robot1">
+        <Translation x="3.9m" y="0" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="purple"/>
+      </Body>
+      <Body ref="NaoDummy" name="robot2">
+        <Translation x="0.485m" y="2.235m" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="black"/>
+      </Body>
+      <Body ref="NaoDummy" name="robot3">
+        <Translation x="0.485m" y="-2.235m" z="320mm"/>
+        <Rotation z="180degree"/>
+        <Set name="NaoColor" value="black"/>
+      </Body>
+    </Compound>
+
+    <Compound name="robots">
+      <Body ref="Nao" name="robot21">
+        <Translation x="-4.5m" y="0" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="blue"/>
+      </Body>
+      <Body ref="Nao" name="robot22">
+        <Translation x="-2.850m" y="-1m" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="red"/>
+      </Body>
+      <Body ref="Nao" name="robot23">
+        <Translation x="-0.375m" y="0" z="320mm"/>
+        <Rotation z="0degree"/>
+        <Set name="NaoColor" value="red"/>
+      </Body>
+    </Compound>
+
+    <Compound name="balls">
+      <Body ref="ball">
+        <Translation x="3.2m" y="0" z="1m"/>
+      </Body>
+    </Compound>
+
+    <Compound ref="field"/>
+
+    <Compound name="scenarios">
+        <Compound name="DynamicBallHandlingChallengeDefender"/>
+    </Compound>
+  </Scene>
+</Simulation>
diff --git a/Config/teams.cfg b/Config/teams.cfg
index 5572217997..0e90f2c4c7 100644
--- a/Config/teams.cfg
+++ b/Config/teams.cfg
@@ -20,5 +20,27 @@ teams = [
       _,
       _
     ];
+  },
+  {
+    name = DBHC;
+    number = 89;
+    fieldPlayerColor = black;
+    goalkeeperColor = purple;
+    scenario = DynamicBallHandlingChallengeAttacker;
+    location = Default;
+    wlanConfig = SPL_A;
+    volume = 50;
+    magicNumber = 5;
+    players = [
+      _,
+      _,
+      _,
+      _,
+      _,
+      _,
+      _,
+      _,
+      _
+    ];
   }
 ];
diff --git a/Src/Libs/SimulatedNao/GameController.cpp b/Src/Libs/SimulatedNao/GameController.cpp
index d4e82dddb8..f466cf295f 100644
--- a/Src/Libs/SimulatedNao/GameController.cpp
+++ b/Src/Libs/SimulatedNao/GameController.cpp
@@ -542,7 +542,7 @@ void GameController::update()
         return SimulatedRobot::getAbsoluteBallPosition(ballPos) && Time::getTimeSince(timeWhenSetPlayBegan) > 10000 && (r.lastPose.translation - ballPos).squaredNorm() < sqr(750.f);
       };
 
-      if(automatic & bit(penalizeLeavingTheField) && !fieldDimensions.isInsideCarpet(r.lastPose.translation))
+      if(bit(penalizeLeavingTheField) && !fieldDimensions.isInsideCarpet(r.lastPose.translation))
         VERIFY(penalty(i, leavingTheField));
       else if(automatic & bit(penalizeIllegalPosition) &&
               (inOpponentHalfBeforeBallIsInPlay() || inPenaltyAreaDuringPenaltyKick() || inFullOwnGoalArea() || inFreeKickArea()))
@@ -612,7 +612,7 @@ void GameController::update()
       break;
 
     case STATE_SET:
-      if(automatic & bit(switchToPlaying) && gameControllerData.gamePhase != GAME_PHASE_PENALTYSHOOT && Time::getTimeSince(timeWhenStateBegan) >= 5000)
+      if(bit(switchToPlaying) && gameControllerData.gamePhase != GAME_PHASE_PENALTYSHOOT && Time::getTimeSince(timeWhenStateBegan) >= 5000)
         playing();
       break;
 
@@ -686,7 +686,7 @@ void GameController::update()
   };
   gameControllerData.secsRemaining = static_cast<int16_t>(getRemainingGameTime(automatic & bit(trueGameState)));
 
-  if(automatic & bit(switchToFinished) && getRemainingGameTime(true) <= 0)
+  if(bit(switchToFinished) && getRemainingGameTime(true) <= 0)
     finished();
 
   if(!(automatic & bit(trueGameState)) && ((gameControllerData.state == STATE_PLAYING && Time::getTimeSince(timeWhenStateBegan) < delayedSwitchToPlaying * 1000) ||
diff --git a/Src/Libs/SimulatedNao/GameController.h b/Src/Libs/SimulatedNao/GameController.h
index d2555c19a6..d371ed6584 100644
--- a/Src/Libs/SimulatedNao/GameController.h
+++ b/Src/Libs/SimulatedNao/GameController.h
@@ -95,7 +95,7 @@ private:
   };
 
   static const int numOfRobots = 2 * MAX_NUM_PLAYERS;
-  static const int halfTime = 600;
+  static const int halfTime = 240;
   static const int readyTime = 45;
   static const int penaltyKickReadyTime = 30;
   static const int kickOffTime = 10;
diff --git a/Src/Modules/BehaviorControl/ExecutedPassesProvider/ExecutedPassesProvider.cpp b/Src/Modules/BehaviorControl/ExecutedPassesProvider/ExecutedPassesProvider.cpp
new file mode 100644
index 0000000000..ce597dd501
--- /dev/null
+++ b/Src/Modules/BehaviorControl/ExecutedPassesProvider/ExecutedPassesProvider.cpp
@@ -0,0 +1,29 @@
+/**
+ * @file ExecutedPassesProvider.cpp
+ *
+ * This file implements a module that keeps track of the number of performed passes based on team communication.
+ *
+ * @author Jo Lienhoop
+ */
+
+#include "ExecutedPassesProvider.h"
+
+MAKE_MODULE(ExecutedPassesProvider);
+
+void ExecutedPassesProvider::reset(ExecutedPasses& theExecutedPasses)
+{
+  theExecutedPasses.number = 0;
+}
+
+void ExecutedPassesProvider::update(ExecutedPasses& theExecutedPasses)
+{
+  if(!theGameState.isPlaying())
+    reset(theExecutedPasses);
+
+  // Check that all teammates have kicked the ball.
+  unsigned numberOfPasses = 0;
+  for(auto const& teammate : theTeamData.teammates)
+    if(teammate.theBehaviorStatus.lastKickTimestamp > theGameState.timeWhenStateStarted)
+      numberOfPasses++;
+  theExecutedPasses.number = numberOfPasses;
+}
diff --git a/Src/Modules/BehaviorControl/ExecutedPassesProvider/ExecutedPassesProvider.h b/Src/Modules/BehaviorControl/ExecutedPassesProvider/ExecutedPassesProvider.h
new file mode 100644
index 0000000000..87b116d12c
--- /dev/null
+++ b/Src/Modules/BehaviorControl/ExecutedPassesProvider/ExecutedPassesProvider.h
@@ -0,0 +1,36 @@
+/**
+ * @file ExecutedPassesProvider.h
+ *
+ * This file declares a module that keeps track of the number of performed passes based on team communication.
+ *
+ * @author Jo Lienhoop
+ */
+
+#pragma once
+
+#include "Framework/Module.h"
+#include "Representations/BehaviorControl/ExecutedPasses.h"
+#include "Representations/Communication/TeamData.h"
+#include "Representations/Infrastructure/GameState.h"
+
+MODULE(ExecutedPassesProvider,
+{,
+  REQUIRES(GameState),
+  REQUIRES(TeamData),
+  PROVIDES(ExecutedPasses),
+});
+
+class ExecutedPassesProvider : public ExecutedPassesProviderBase
+{
+  /**
+   * This method is called when the representation provided needs to be reset to its initial values.
+   * @param theExecutedPasses The representation to reset.
+   */
+  void reset(ExecutedPasses& theExecutedPasses);
+
+  /**
+   * This method is called when the representation provided needs to be updated.
+   * @param theExecutedPasses The representation updated.
+   */
+  void update(ExecutedPasses& theExecutedPasses) override;
+};
diff --git a/Src/Modules/BehaviorControl/ExpectedGoalsProvider/ExpectedGoalsProvider.cpp b/Src/Modules/BehaviorControl/ExpectedGoalsProvider/ExpectedGoalsProvider.cpp
index 12701f2bb3..c53dc74f8d 100644
--- a/Src/Modules/BehaviorControl/ExpectedGoalsProvider/ExpectedGoalsProvider.cpp
+++ b/Src/Modules/BehaviorControl/ExpectedGoalsProvider/ExpectedGoalsProvider.cpp
@@ -117,18 +117,61 @@ Angle ExpectedGoalsProvider::getOpeningAngle(const Vector2f& pointOnField) const
   wheel.addSector(Rangea(angleToRightPost, angleToLeftPost), std::numeric_limits<float>::max(), SectorWheel::Sector::goal);
 
   // TODO: Replace the ObstacleModel with the GlobalOpponentsModel once implemented
-  for(const auto& obstacle : theGlobalOpponentsModel.opponents)
+  addSectorsToWheel(theObstacleModel.obstacles, theRobotPose, wheel, pointOnField, angleToLeftPost, angleToRightPost, std::nullopt, false);
+
+  if(theGameState.isGoalkeeper() &&
+     theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) <= 15000)
   {
-    const Vector2f& obstacleOnField = obstacle.position;
+    for(auto const& teammate : theTeamData.teammates)
+    {
+      if(theFrameInfo.getTimeSince(teammate.theFrameInfo.time) > 3000 ||
+         !teammate.theRobotStatus.isUpright) // TODO: Check for more constraints
+        continue;
+
+      addSectorsToWheel(teammate.theObstacleModel.obstacles, teammate.theRobotPose, wheel, pointOnField, angleToLeftPost, angleToRightPost, opponentRobotWidth, true);
+    }
+  }
+
+  sectors = wheel.finish();
+
+  // Find the maximum opening angle i.e. the free sector with the largest size
+  for(const SectorWheel::Sector& sector : sectors)
+    if(sector.type == SectorWheel::Sector::goal &&
+       sector.angleRange.getSize() >= openingAngle)
+      openingAngle = sector.angleRange.getSize();
+
+  return openingAngle;
+}
+
+void ExpectedGoalsProvider::addSectorsToWheel(const std::vector<Obstacle>& obstacles,
+                                              const Pose2f& robotPose,
+                                              SectorWheel& wheel,
+                                              Vector2f wheelCenter,
+                                              Angle angleToLeftPost,
+                                              Angle angleToRightPost,
+                                              std::optional<float> constantWidth = std::nullopt,
+                                              bool mirrorObstacles = false) const
+{
+  for(const Obstacle& obstacle : obstacles)
+  {
+    if(obstacle.isTeammate())
+      continue;
+
+    Vector2f obstacleOnField = robotPose * obstacle.center;
     // Skip opponents inside of their goal (behind the groundline)
     if(obstacleOnField.x() > (theFieldDimensions.xPosOpponentGroundLine + theFieldDimensions.xPosOpponentGoal) * 0.5f)
       continue;
 
+    // This hack is used for the Dynamic Ball Handling Challenge. It mirrors the positions of the communicated opponents far in the opponent half in regards to their y-axis. This is supposed to make the goalkeeper select the forward with the worse rating for the first pass, during which the opponents are not allowed to move. The second pass to the other forward should allow the receiver to perform a direct goal shot without the opponent in the way.
+    if(mirrorObstacles &&
+       obstacleOnField.x() >= theFieldDimensions.centerCircleRadius * 2.f)
+      obstacleOnField = Vector2f(obstacleOnField.x(), -opponentYPosRange.limit(obstacleOnField.y()));
+
     // Check if the opponent is inside of the goal sector
-    const float width = (obstacle.left - obstacle.right).norm() + 4.f * theBallSpecification.radius;
-    const float distance = std::sqrt(std::max((obstacleOnField - pointOnField).squaredNorm() - sqr(width / 2.f), 1.f));
+    const float width = constantWidth.value_or((obstacle.left - obstacle.right).norm()) + 4.f * theBallSpecification.radius;
+    const float distance = std::sqrt(std::max((obstacleOnField - wheelCenter).squaredNorm() - sqr(width / 2.f), 1.f));
     const float radius = std::atan(width / (2.f * distance));
-    const Angle direction = (obstacleOnField - pointOnField).angle();
+    const Angle direction = (obstacleOnField - wheelCenter).angle();
     if(direction - radius > angleToLeftPost ||
        direction + radius < angleToRightPost)
       continue;
@@ -136,15 +179,6 @@ Angle ExpectedGoalsProvider::getOpeningAngle(const Vector2f& pointOnField) const
     // Add the opponent to the sector wheel
     wheel.addSector(Rangea(Angle::normalize(direction - radius), Angle::normalize(direction + radius)), distance, SectorWheel::Sector::obstacle);
   }
-
-  sectors = wheel.finish();
-  // Find the maximum opening angle i.e. the free sector with the largest size
-  for(const SectorWheel::Sector& sector : sectors)
-    if(sector.type == SectorWheel::Sector::goal &&
-       sector.angleRange.getSize() >= openingAngle)
-      openingAngle = sector.angleRange.getSize();
-
-  return openingAngle;
 }
 
 Angle ExpectedGoalsProvider::getOpponentOpeningAngle(const Vector2f& pointOnField) const
diff --git a/Src/Modules/BehaviorControl/ExpectedGoalsProvider/ExpectedGoalsProvider.h b/Src/Modules/BehaviorControl/ExpectedGoalsProvider/ExpectedGoalsProvider.h
index 17bc8a042d..c8638599f8 100644
--- a/Src/Modules/BehaviorControl/ExpectedGoalsProvider/ExpectedGoalsProvider.h
+++ b/Src/Modules/BehaviorControl/ExpectedGoalsProvider/ExpectedGoalsProvider.h
@@ -13,20 +13,30 @@
 #include "Representations/BehaviorControl/ExpectedGoals.h"
 #include "Representations/Configuration/BallSpecification.h"
 #include "Representations/Configuration/FieldDimensions.h"
-#include "Representations/Modeling/GlobalOpponentsModel.h"
+#include "Representations/Infrastructure/FrameInfo.h"
+#include "Representations/Communication/TeamData.h"
+#include "Representations/Modeling/ObstacleModel.h"
+#include "Representations/Modeling/RobotPose.h"
+#include "Representations/Infrastructure/GameState.h"
 #include "Tools/BehaviorControl/SectorWheel.h"
 
 MODULE(ExpectedGoalsProvider,
 {,
   REQUIRES(BallSpecification),
   REQUIRES(FieldDimensions),
-  REQUIRES(GlobalOpponentsModel),
+  REQUIRES(FrameInfo),
+  REQUIRES(ObstacleModel),
+  REQUIRES(RobotPose),
+  REQUIRES(TeamData),
+  REQUIRES(GameState),
   PROVIDES(ExpectedGoals),
   DEFINES_PARAMETERS(
   {,
     (float)(0.01f) minValue, /**< Minimum probability of a successful goal shot in the worst situation possible. */
+    (float)(900.f) opponentRobotWidth, /**< Constant width approxiation in mm for the opponent positions that have been extracted from the communicated obstacle model of teammates. */
+    (Rangef)(-600.f, 600.f) opponentYPosRange, /**< Opponent width will be clipped to this range which will make sure that the shadow casted by the opponent in the rating function will worsen the rating of the forward player in the Dynamic Ball Handling Challenge. */
     (Angle)(0_deg) minOpeningAngle, /**< Opening angle for the goal shot line to be considered blocked */
-    (Angle)(30_deg) maxOpeningAngle, /**< Opening angle for the goal shot line to be considered free */
+    (Angle)(25_deg) maxOpeningAngle, /**< Opening angle for the goal shot line to be considered free */
     (float)(100.f) cellSize, /**< Size of each grid cell in mm on the field, lower number results in higher resolution for the heatmap */
     (unsigned char)(255) heatmapAlpha, /**< Transparency of the heatmap between 0 (invisible) and 255 (opaque) */
     (ColorRGBA)(213, 17, 48) worstRatingColor, /**< Red color in RGB corresponding to a pass rating value of 0 in the heatmap */
@@ -88,6 +98,23 @@ private:
    */
   Angle getOpeningAngle(const Vector2f& pointOnField) const;
 
+  /**
+   * Converts a list of obstacle objects into sectors and inserts them into the sector wheel.
+   * Only opponent obstacles are considered, all other elements are ignored.
+   * @param obstacles A list of obstacles.
+   * @param robotPose The pose of the observing robot.
+   * @param wheel A reference to the sector wheel storing the obstacles.
+   * @param wheelCenter The center point (in absolute coordinates) of the sector wheel.
+   */
+  void addSectorsToWheel(const std::vector<Obstacle>& obstacles,
+                         const Pose2f& robotPose,
+                         SectorWheel& wheel,
+                         Vector2f wheelCenter,
+                         Angle angleToLeftPost,
+                         Angle angleToRightPost,
+                         std::optional<float> constantWidth,
+                         bool mirrorObstacles) const;
+
   /**
    * Calculates the opening angle on the own goal from the given position, not taking into account the known obstacles.
    * @param pointOnField The position to shoot from.
diff --git a/Src/Modules/BehaviorControl/FieldBallProvider/FieldBallProvider.cpp b/Src/Modules/BehaviorControl/FieldBallProvider/FieldBallProvider.cpp
index 4a1e3a325a..64ba367951 100644
--- a/Src/Modules/BehaviorControl/FieldBallProvider/FieldBallProvider.cpp
+++ b/Src/Modules/BehaviorControl/FieldBallProvider/FieldBallProvider.cpp
@@ -38,7 +38,7 @@ void FieldBallProvider::update(FieldBall& fieldBall)
 
   checkIfBallIsRollingTowardsAGoal(fieldBall.isRollingTowardsOpponentGoal, fieldBall.isRollingTowardsOwnGoal,
                                    fieldBall.positionOnField, theBallModel.estimate.velocity);
-  checkIfBallIsPassingOwnYAxis(fieldBall.intersectionPositionWithOwnYAxis, fieldBall.timeUntilIntersectsOwnYAxis, theBallModel.estimate);
+  checkIfBallIsPassingOwnYAxis(fieldBall.intersectionPositionWithOwnYAxis, fieldBall.timeUntilIntersectsOwnYAxis, theBallModel.estimate, fieldBall.interceptBall);
   checkIfBallIsPassingOwnXAxis(fieldBall.intersectionPositionWithOwnXAxis, fieldBall.timeUntilIntersectsOwnXAxis, theBallModel.estimate);
   checkIfBallIsInsideOwnPenaltyArea(fieldBall);
   checkBallPositionIsConsistentWithGameState(fieldBall, theGameState);
@@ -89,13 +89,20 @@ void FieldBallProvider::checkIfBallIsPassingOwnXAxis(Vector2f& intersectionPosit
   }
 }
 
-void FieldBallProvider::checkIfBallIsPassingOwnYAxis(Vector2f& intersectionPositionWithOwnYAxis, float& timeUntilIntersectsOwnYAxis, const BallState& estimate)
+void FieldBallProvider::checkIfBallIsPassingOwnYAxis(Vector2f& intersectionPositionWithOwnYAxis, float& timeUntilIntersectsOwnYAxis, const BallState& estimate, const bool interceptBall)
 {
   intersectionPositionWithOwnYAxis = Vector2f::Zero();
   timeUntilIntersectsOwnYAxis = std::numeric_limits<float>::max();
 
   const Vector2f& ballPosRel = estimate.position;
-  const Vector2f& ballVelRel = estimate.velocity;
+
+  float scaling;
+  if(interceptBall)
+    scaling = mapToRange(ballPosRel.norm(), 300.f, 1000.f, 1.f, 1.5f);
+  else
+    scaling = mapToRange(ballPosRel.norm(), 600.f, 1500.f, 1.f, 1.2f);
+
+  const Vector2f& ballVelRel = estimate.velocity * scaling;
   if(ballVelRel.x() >= 0.f || ballPosRel.x() < 0.f) // Ball does not move or moves away
     return;
   Vector2f intersection;
@@ -154,7 +161,14 @@ void FieldBallProvider::calculateInterceptedBallEndPosition(FieldBall& fieldBall
   float timeUntilIntersectsOwnXAxis = fieldBall.timeUntilIntersectsOwnXAxis;
   Vector2f intersectionPositionWithOwnYAxis = fieldBall.intersectionPositionWithOwnYAxis;
   Vector2f intersectionPositionWithOwnXAxis = fieldBall.intersectionPositionWithOwnXAxis;
-  Vector2f endPosition = fieldBall.endPositionRelative;
+
+  float scaling;
+  if(fieldBall.interceptBall)
+    scaling = mapToRange(estimate.position.norm(), 300.f, 1000.f, 1.f, 1.5f);
+  else
+    scaling = mapToRange(estimate.position.norm(), 600.f, 1500.f, 1.f, 1.2f);
+
+  Vector2f endPosition = BallPhysics::getEndPosition(theBallModel.estimate.position, theBallModel.estimate.velocity * scaling, theBallSpecification.friction);
   bool isRollingTowardsOpponentGoal = fieldBall.isRollingTowardsOpponentGoal;
   bool isRollingTowardsOwnGoal = fieldBall.isRollingTowardsOwnGoal;
   // The ball must be a min distance away and the risky estimate must have a higher velocity
@@ -165,7 +179,7 @@ void FieldBallProvider::calculateInterceptedBallEndPosition(FieldBall& fieldBall
     estimate.position = estimate.position * (1.f - ballDistanceScaling) + theBallModel.riskyMovingEstimate.position * ballDistanceScaling;
     estimate.velocity = estimate.velocity * (1.f - ballDistanceScaling) + theBallModel.riskyMovingEstimate.velocity * ballDistanceScaling;
     endPosition = BallPhysics::getEndPosition(estimate.position, estimate.velocity, theBallSpecification.friction);
-    checkIfBallIsPassingOwnYAxis(intersectionPositionWithOwnYAxis, timeUntilIntersectsOwnYAxis, estimate);
+    checkIfBallIsPassingOwnYAxis(intersectionPositionWithOwnYAxis, timeUntilIntersectsOwnYAxis, estimate, fieldBall.interceptBall);
     checkIfBallIsPassingOwnXAxis(intersectionPositionWithOwnXAxis, timeUntilIntersectsOwnXAxis, estimate);
     checkIfBallIsRollingTowardsAGoal(isRollingTowardsOpponentGoal, isRollingTowardsOwnGoal,
                                      theRobotPose * estimate.position, estimate.velocity);
@@ -177,7 +191,8 @@ void FieldBallProvider::calculateInterceptedBallEndPosition(FieldBall& fieldBall
                                               (theFallDownState.state == FallDownState::upright || theFallDownState.state == FallDownState::staggering) &&
                                               !isRollingTowardsOpponentGoal &&
                                               ballDistance < 5000.f &&
-                                              endPosition.x() <= 200.f;
+                                              endPosition.x() <= 200.f &&
+                                              fieldBall.positionRelative.x() > 0.f;
 
     const bool yIntersectionCondition = between<float>(intersectionPositionWithOwnYAxis.y(), -theBehaviorParameters.ballCatchMaxWalkDistance, theBehaviorParameters.ballCatchMaxWalkDistance) &&
                                         between<float>(timeUntilIntersectsOwnYAxis, 0.1f, 3.0f);
diff --git a/Src/Modules/BehaviorControl/FieldBallProvider/FieldBallProvider.h b/Src/Modules/BehaviorControl/FieldBallProvider/FieldBallProvider.h
index 11ee269040..ecf1e364e5 100644
--- a/Src/Modules/BehaviorControl/FieldBallProvider/FieldBallProvider.h
+++ b/Src/Modules/BehaviorControl/FieldBallProvider/FieldBallProvider.h
@@ -68,7 +68,7 @@ class FieldBallProvider : public FieldBallProviderBase
    * @param timeUntilIntersectsOwnYAxis Time until intersection (in s)
    * @param estimate The ball estimate to be used
    */
-  void checkIfBallIsPassingOwnYAxis(Vector2f& intersectionPositionWithOwnYAxis, float& timeUntilIntersectsOwnYAxis, const BallState& estimate);
+  void checkIfBallIsPassingOwnYAxis(Vector2f& intersectionPositionWithOwnYAxis, float& timeUntilIntersectsOwnYAxis, const BallState& estimate, const bool interceptBall);
 
   void checkIfBallIsPassingOwnXAxis(Vector2f& intersectionPositionWithOwnXAxis, float& timeUntilIntersectsOwnXAxis, const BallState& estimate);
 
diff --git a/Src/Modules/BehaviorControl/FieldRatingProvider/FieldRatingProvider.cpp b/Src/Modules/BehaviorControl/FieldRatingProvider/FieldRatingProvider.cpp
index 53e5446f27..88933a8295 100644
--- a/Src/Modules/BehaviorControl/FieldRatingProvider/FieldRatingProvider.cpp
+++ b/Src/Modules/BehaviorControl/FieldRatingProvider/FieldRatingProvider.cpp
@@ -74,11 +74,10 @@ void FieldRatingProvider::update(FieldRating& fieldRating)
     pv += getObstaclePotential(x, y, calculateFieldDirection);
   };
 
-  fieldRating.potentialOverall = [this](PotentialValue& pv, const float x, const float y, bool& teammateArea, const bool calculateFieldDirection, const int passTarget)
+  fieldRating.potentialOverall = [this](PotentialValue& pv, const float x, const float y, int& teammatePass, const bool calculateFieldDirection, const int passTarget)
   {
     lastRequestedPassTarget = passTarget;
-    PotentialValue teammatePV = getTeammatesPotential(x, y, calculateFieldDirection, passTarget);
-    teammateArea = teammatePV.value < 0.f;
+    PotentialValue teammatePV = getTeammatesPotential(x, y, calculateFieldDirection, passTarget, teammatePass);
     pv += teammatePV;
   };
 
@@ -190,7 +189,8 @@ void FieldRatingProvider::draw()
       }
       if(teammateDrawing)
       {
-        PotentialValue teammate = getTeammatesPotential(x, y, calculateFieldDirection, lastRequestedPassTarget);
+        int teammateNumber;
+        PotentialValue teammate = getTeammatesPotential(x, y, calculateFieldDirection, lastRequestedPassTarget, teammateNumber);
         if(teammate.value < 0.f)
           teammate.value -= std::max(0.f, pvBallNear.value);
         pv += teammate;
@@ -470,7 +470,7 @@ void FieldRatingProvider::updateTeammateData(const Vector2f& useBallPose)
   }
 }
 
-PotentialValue FieldRatingProvider::getTeammatesPotential(const float x, const float y, const bool calculateFieldDirection, const int passTarget)
+PotentialValue FieldRatingProvider::getTeammatesPotential(const float x, const float y, const bool calculateFieldDirection, const int passTarget, int& teammatePass)
 {
   Vector2f clippedBallPose = theFieldBall.interceptedEndPositionOnField;
   clippedBallPose.x() = std::max(clippedBallPose.x(), minXCoordinateForPass);
@@ -483,6 +483,7 @@ PotentialValue FieldRatingProvider::getTeammatesPotential(const float x, const f
   std::size_t index = -1;
   const Vector2f fieldPoint(x, y);
   const float ownHalfInterpolation = mapToRange(x, minXCoordinateForPass, minXCoordinateForPass + 2.f * interpolationZoneInOwnHalf, 0.f, 1.f);
+  float bestSingleRating = 0.f;
   for(const auto& teammate : theGlobalTeammatesModel.teammates)
   {
     index++;
@@ -552,6 +553,12 @@ PotentialValue FieldRatingProvider::getTeammatesPotential(const float x, const f
       const Vector2f direction = functionLinearDer(poseVector, poseDistance, 1.f);
       pv.direction += direction * std::abs(rating);
     }
+
+    if(bestSingleRating > rating)
+    {
+      teammatePass = teammate.playerNumber;
+      bestSingleRating = rating;
+    }
   }
   return pv;
 }
diff --git a/Src/Modules/BehaviorControl/FieldRatingProvider/FieldRatingProvider.h b/Src/Modules/BehaviorControl/FieldRatingProvider/FieldRatingProvider.h
index b9735e556d..083a1c31de 100644
--- a/Src/Modules/BehaviorControl/FieldRatingProvider/FieldRatingProvider.h
+++ b/Src/Modules/BehaviorControl/FieldRatingProvider/FieldRatingProvider.h
@@ -55,7 +55,7 @@ MODULE(FieldRatingProvider,
     // teammate
     (float)(0.6f) teammateValue, // max possible attract value for a teammate
     (float)(3000.f) teammateAttractRange, // max distance a teammate influences the potential field.
-    (float)(300.f) bestRelativePose, // best relative pass pose relative from the teammate in direction of the goal
+    (float)(0.f) bestRelativePose, // best relative pass pose relative from the teammate in direction of the goal
     (float)(500.f) minTeammatePassDistance, // teammate must stand at least this distance far away from us
     (float)(2000.f) maxTeammatePassDistance, // if teammate stands this far away (or more) then the rating is not reduced
     (float)(1000.f) teammateMinDistanceToObstacle,
@@ -181,7 +181,7 @@ private:
 
   PotentialValue getGoalAnglePotential(const float x, const float y, const bool calculateFieldDirection);
 
-  PotentialValue getTeammatesPotential(const float x, const float y, const bool calculateFieldDirection, const int passTarget);
+  PotentialValue getTeammatesPotential(const float x, const float y, const bool calculateFieldDirection, const int passTarget, int& teammatePass);
 
   PotentialValue getBallNearPotential(const float x, const float y, const bool calculateFieldDirection);
 
diff --git a/Src/Modules/BehaviorControl/Libraries/LibLookActiveProvider.cpp b/Src/Modules/BehaviorControl/Libraries/LibLookActiveProvider.cpp
index d83a404dc5..21e73f9af6 100644
--- a/Src/Modules/BehaviorControl/Libraries/LibLookActiveProvider.cpp
+++ b/Src/Modules/BehaviorControl/Libraries/LibLookActiveProvider.cpp
@@ -168,11 +168,6 @@ Angle LibLookActiveProvider::clipPanToBall(const Angle pan) const
   Angle tolerance = theCameraInfo.openingAngleWidth / 6.f;
   const Angle ballAngle = theBallPositionRelative.angle();
 
-  if(teamBallIsUsed)
-  {
-    const float distance = (theTeammatesBallModel.position - theRobotPose.translation).norm();
-    tolerance += std::atan(teammatesBallModelError / distance);
-  }
   return Rangea(ballAngle - tolerance, ballAngle + tolerance).limit(pan);
 }
 
@@ -224,13 +219,16 @@ bool LibLookActiveProvider::ballInSight() const
   return Rangea(currentPan - tolerance, currentPan + tolerance).isInside(ballAngle);
 }
 
-bool LibLookActiveProvider::ballPositionUnknown(const bool onlyOwnBall) const
+bool LibLookActiveProvider::ballPositionUnknown([[maybe_unused]] const bool onlyOwnBall) const
 {
-  const bool disappeared = theFrameInfo.getTimeSince(theBallModel.timeWhenDisappeared) > 100;
+  const bool disappeared = theFrameInfo.getTimeSince(theBallModel.timeWhenDisappeared) > ballPositionUnknownTimeout;
   const bool notSeen = theFrameInfo.getTimeSince(theBallModel.timeWhenLastSeen) > ballPositionUnknownTimeout;
-  const bool globalNotSeen = !theTeammatesBallModel.isValid;
+  const bool globalNotSeen = !teamBallIsUsed || !theTeammatesBallModel.isValid;
+
+  if(!globalNotSeen)  // if we use the global ball and it is valid, then the ballposition is known
+    return globalNotSeen;
 
-  return disappeared || (notSeen && (onlyOwnBall || globalNotSeen));
+  return disappeared || notSeen; // global ball is unknown or not used AND we do not know the ball position either
 }
 
 void LibLookActiveProvider::calculateSpeedFactors()
diff --git a/Src/Modules/BehaviorControl/Libraries/LibLookActiveProvider.h b/Src/Modules/BehaviorControl/Libraries/LibLookActiveProvider.h
index 44d285e45d..4b0dac4176 100644
--- a/Src/Modules/BehaviorControl/Libraries/LibLookActiveProvider.h
+++ b/Src/Modules/BehaviorControl/Libraries/LibLookActiveProvider.h
@@ -65,7 +65,6 @@ MODULE(LibLookActiveProvider,
     (float) maxObstacleDistanceToBeLookedAt,
     (int) maxObstacleAgeToBeLookedAt,
     (Angle) cameraChoiceHysteresis,
-    (float) teammatesBallModelError, /**< estimation of the worst-case TeammatesBallModel error */
   }),
 });
 
diff --git a/Src/Modules/BehaviorControl/PassEvaluationProvider/PassEvaluationProvider.cpp b/Src/Modules/BehaviorControl/PassEvaluationProvider/PassEvaluationProvider.cpp
index 0ac37eb2cc..46e2ffcdbe 100644
--- a/Src/Modules/BehaviorControl/PassEvaluationProvider/PassEvaluationProvider.cpp
+++ b/Src/Modules/BehaviorControl/PassEvaluationProvider/PassEvaluationProvider.cpp
@@ -20,9 +20,9 @@ PassEvaluationProvider::PassEvaluationProvider()
 
 void PassEvaluationProvider::update(PassEvaluation& thePassEvaluation)
 {
-  thePassEvaluation.getRating = [this](const Vector2f& pointOnField) -> float
+  thePassEvaluation.getRating = [this](const Vector2f& baseOnField, const Vector2f& targetOnField) -> float
   {
-    return getRating(pointOnField);
+    return getRating(baseOnField, targetOnField);
   };
 
   DECLARE_DEBUG_DRAWING("module:PassEvaluationProvider:heatmap", "drawingOnField");
@@ -37,21 +37,21 @@ void PassEvaluationProvider::update(PassEvaluation& thePassEvaluation)
     draw();
 }
 
-float PassEvaluationProvider::getRating(const Vector2f& pointOnField)
+float PassEvaluationProvider::getRating(const Vector2f& baseOnField, const Vector2f& targetOnField)
 {
-  if(!theFieldDimensions.isInsideField(pointOnField))
+  if(!theFieldDimensions.isInsideField(targetOnField))
     return 0.f;
 
   if(lastUpdateParameters != theFrameInfo.time)
   {
     lastUpdateParameters = theFrameInfo.time;
-    updateParameters();
+    updateParameters(baseOnField);
   }
-  // Calculate the minimum distance from the opponents and teammates (separately) to the target itself as well as the line from the ball to the target
+  // Calculate the minimum distance from the opponents and teammates (separately) to the target itself as well as the line from the base to the target
   float minOpponentDistToTarget = std::numeric_limits<float>::max();
   float minOpponentDistToLine = std::numeric_limits<float>::max();
   for(const Vector2f& opponentOnField : opponentsOnField)
-    updateMinDistances(pointOnField, opponentOnField, minOpponentDistToTarget, minOpponentDistToLine);
+    updateMinDistances(targetOnField, opponentOnField, minOpponentDistToTarget, minOpponentDistToLine);
 
   // Estimated probability that no opponent would be at the pass target
   const float passTargetFree = calcPassTargetFree ? mapToRange(minOpponentDistToTarget, 0.f, opponentDistToTargetThreshold, 0.f, 1.f) : 1.f;
@@ -60,36 +60,66 @@ float PassEvaluationProvider::getRating(const Vector2f& pointOnField)
   const float passLineFree = calcPassLineFree ? mapToRange(minOpponentDistToLine, obstacleBlockingRadius, opponentDistToLineThreshold, 0.f, 1.f) : 1.f;
 
   // Estimated probability that the pass would be within the field and not go out of its boundary
-  const float passTargetInField = calcPassTargetInField ? mapToRange(getDistanceToFieldBorder(pointOnField), 0.f, distToBoundaryThreshold, 0.f, 1.f) : 1.f;
+  const float passTargetInField = calcPassTargetInField ? mapToRange(getDistanceToFieldBorder(targetOnField), 0.f, distToBoundaryThreshold, 0.f, 1.f) : 1.f;
 
   // Estimated probability that no teammate's direct shot towards the opponent's goal would be blocked
-  const float shotLineFree = calcShotLineFree ? 1.f - ((1.f - isShotLineFree(pointOnField)) * theExpectedGoals.xG(ballOnField)) : 1.f;
+  const float shotLineFree = calcShotLineFree ? 1.f - ((1.f - isShotLineFree(targetOnField)) * theExpectedGoals.xG(basePositionOnField)) : 1.f;
 
   // Estimated probability that the target is within the kick range
-  const float targetInRange = calcShotDistance ? isTargetInRange(pointOnField) : 1.f;
+  const float targetInRange = calcShotDistance ? isTargetInRange(targetOnField) : 1.f;
 
   // Estimated probability that the pass would be successful based on the above combined conditions
   const float combinedValue = passTargetFree * passLineFree * passTargetInField * shotLineFree * targetInRange;
   return std::max(minValue, combinedValue);
 }
 
-void PassEvaluationProvider::updateParameters()
+void PassEvaluationProvider::updateParameters(const Vector2f& baseOnField)
 {
-  ballOnField = theFieldBall.recentBallPositionOnField();
-  ballToLeftGoalPost = (leftGoalPost - ballOnField).angle();
-  ballToRightGoalPost = (rightGoalPost - ballOnField).angle();
-  ballToLeftGoalArea = (leftGoalPost + goalPostShift - ballOnField).angle();
-  ballToRightGoalArea = (rightGoalPost - goalPostShift - ballOnField).angle();
+  basePositionOnField = baseOnField;
+  baseToLeftGoalPost = (leftGoalPost - basePositionOnField).angle();
+  baseToRightGoalPost = (rightGoalPost - basePositionOnField).angle();
+  baseToLeftGoalArea = (leftGoalPost + goalPostShift - basePositionOnField).angle();
+  baseToRightGoalArea = (rightGoalPost - goalPostShift - basePositionOnField).angle();
   opponentsOnField.clear();
   // TODO: Replace the ObstacleModel with the GlobalOpponentsModel once implemented
-  for(const auto& obstacle : theGlobalOpponentsModel.opponents)
+  for(const Obstacle& obstacle : theObstacleModel.obstacles)
   {
-    Vector2f obstacleOnField = obstacle.position;
-    // Assume the opponent is oriented towards the ball and shift its position in an attempt to rate pass positions "in front of them" worse than behind them. The minimum ensures that the obstacle is not shifted onto the other side of the ball when the initial distance is smaller than opponentShiftToBall.
-    const Vector2f obstacleToBall = ballOnField - obstacleOnField;
-    obstacleOnField += obstacleToBall.normalized(std::min(opponentShiftToBall, obstacleToBall.norm()));
+    if(obstacle.isTeammate())
+      continue;
+    Vector2f obstacleOnField = theRobotPose * obstacle.center;
+    // Assume the opponent is oriented towards the base and shift its position in an attempt to rate pass positions "in front of them" worse than behind them. The minimum ensures that the obstacle is not shifted onto the other side of the base when the initial distance is smaller than opponentShiftToBase.
+    const Vector2f obstacleToBase = basePositionOnField - obstacleOnField;
+    obstacleOnField += obstacleToBase.normalized(std::min(opponentShiftToBase, obstacleToBase.norm()));
     opponentsOnField.emplace_back(obstacleOnField);
   }
+
+  // Consider obstacles from the communicated models of teammates for the Dynamic Ball Handling Challenge.
+  if(!theGameState.isGoalkeeper() ||
+     theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) > 15000)
+    return;
+  for(auto const& teammate : theTeamData.teammates)
+  {
+    if(theFrameInfo.getTimeSince(teammate.theFrameInfo.time) > 3000 ||
+       !teammate.theRobotStatus.isUpright) // TODO: Check for more constraints
+      continue;
+
+    for(const Obstacle& obstacle : teammate.theObstacleModel.obstacles)
+    {
+      if(obstacle.isTeammate())
+        continue;
+
+      Vector2f obstacleOnField = teammate.theRobotPose * obstacle.center;
+
+      // This hack is used for the Dynamic Ball Handling Challenge. It mirrors the positions of the communicated opponents far in the opponent half in regards to their y-axis. This is supposed to make the goalkeeper select the forward with the worse rating for the first pass, during which the opponents are not allowed to move. The second pass to the other forward should allow the receiver to perform a direct goal shot without the opponent in the way.
+      if(obstacleOnField.x() >= theFieldDimensions.centerCircleRadius * 2.f)
+        obstacleOnField = Vector2f(obstacleOnField.x(), -obstacleOnField.y());
+
+      // Assume the opponent is oriented towards the base and shift its position in an attempt to rate pass positions "in front of them" worse than behind them. The minimum ensures that the obstacle is not shifted onto the other side of the base when the initial distance is smaller than opponentShiftToBase.
+      const Vector2f obstacleToBase = basePositionOnField - obstacleOnField;
+      obstacleOnField += obstacleToBase.normalized(std::min(opponentShiftToBase, obstacleToBase.norm()));
+      opponentsOnField.emplace_back(obstacleOnField);
+    }
+  }
 }
 
 void PassEvaluationProvider::updateMinDistances(const Vector2f& pointOnField, const Vector2f& obstacleOnField, float& minDistToTarget, float& minDistToLine) const
@@ -97,31 +127,31 @@ void PassEvaluationProvider::updateMinDistances(const Vector2f& pointOnField, co
   const float distToTarget = (pointOnField - obstacleOnField).norm();
   if(distToTarget < minDistToTarget)
     minDistToTarget = distToTarget;
-  const float distToLine = Geometry::getDistanceToEdge(Geometry::Line(ballOnField, (pointOnField - ballOnField)), obstacleOnField);
+  const float distToLine = Geometry::getDistanceToEdge(Geometry::Line(basePositionOnField, (pointOnField - basePositionOnField)), obstacleOnField);
   if(distToLine < minDistToLine)
     minDistToLine = distToLine;
 }
 
 float PassEvaluationProvider::isShotLineFree(const Vector2f& pointOnField) const
 {
-  if(ballOnField.x() > theFieldDimensions.xPosOpponentGroundLine)
+  if(basePositionOnField.x() > theFieldDimensions.xPosOpponentGroundLine)
     return 1.f;
-  const Angle ballToPoint = (pointOnField - ballOnField).angle();
-  // Interpolate the ball to point angle between each goal post angle and its offset to create a transition
-  const float leftSideTransition = mapToRange(ballToPoint, ballToLeftGoalPost, ballToLeftGoalArea, 0_deg, Angle(1.f));
-  const float rightSideTransition = mapToRange(ballToPoint, ballToRightGoalArea, ballToRightGoalPost, Angle(1.f), 0_deg);
-  // Both values equal 1.f when the point is inside the triangle formed by the ball and both goal posts, 0.f when outside
+  const Angle baseToPoint = (pointOnField - basePositionOnField).angle();
+  // Interpolate the base to point angle between each goal post angle and its offset to create a transition
+  const float leftSideTransition = mapToRange(baseToPoint, baseToLeftGoalPost, baseToLeftGoalArea, 0_deg, Angle(1.f));
+  const float rightSideTransition = mapToRange(baseToPoint, baseToRightGoalArea, baseToRightGoalPost, Angle(1.f), 0_deg);
+  // Both values equal 1.f when the point is inside the triangle formed by the base and both goal posts, 0.f when outside
   if(leftSideTransition == rightSideTransition)
     return leftSideTransition;
-  // Otherwise the point is inside the transition area on the edges of the ball to goal opening angle
+  // Otherwise the point is inside the transition area on the edges of the base to goal opening angle
   return leftSideTransition + rightSideTransition;
 }
 
 float PassEvaluationProvider::isTargetInRange(const Vector2f& pointOnField) const
 {
   const float maxDist = theGameState.isFreeKick() && theGameState.isForOwnTeam() ? distancePenaltyThresholdFreeKick : distancePenaltyThresholdPlaying;
-  const float ballDist = (ballOnField - pointOnField).norm();
-  return ballDist < maxDist ? 1.f : std::exp(-0.5f * sqr(ballDist - maxDist) / sqr(distancePenaltyDeviation));
+  const float baseDist = (basePositionOnField - pointOnField).norm();
+  return baseDist < maxDist ? 1.f : std::exp(-0.5f * sqr(baseDist - maxDist) / sqr(distancePenaltyDeviation));
 }
 
 float PassEvaluationProvider::getDistanceToFieldBorder(const Vector2f& pointOnField) const
@@ -138,7 +168,7 @@ void PassEvaluationProvider::draw()
     for(float x = ownFieldCorner.x(); x <= opponentFieldCorner.x(); x += cellSize)
     {
       const Vector2f position(x, y);
-      float rating = getRating(position); // * theExpectedGoals.getOpponentRating(position);
+      float rating = getRating(theFieldBall.recentBallPositionOnField(), position); // * theExpectedGoals.getOpponentRating(position);
       if(drawCombinedHeatmap)
         rating *= theExpectedGoals.getRating(position);
       // Linear interpolation of rating in [0, 1] between the two colors for the heatmap
diff --git a/Src/Modules/BehaviorControl/PassEvaluationProvider/PassEvaluationProvider.h b/Src/Modules/BehaviorControl/PassEvaluationProvider/PassEvaluationProvider.h
index 28ca0e0242..08a8990626 100644
--- a/Src/Modules/BehaviorControl/PassEvaluationProvider/PassEvaluationProvider.h
+++ b/Src/Modules/BehaviorControl/PassEvaluationProvider/PassEvaluationProvider.h
@@ -13,6 +13,7 @@
 #include "Representations/BehaviorControl/ExpectedGoals.h"
 #include "Representations/BehaviorControl/FieldBall.h"
 #include "Representations/BehaviorControl/PassEvaluation.h"
+#include "Representations/Communication/TeamData.h"
 #include "Representations/Configuration/BallSpecification.h"
 #include "Representations/Configuration/FieldDimensions.h"
 #include "Representations/Infrastructure/FrameInfo.h"
@@ -26,20 +27,22 @@ MODULE(PassEvaluationProvider,
   REQUIRES(FieldBall),
   REQUIRES(FieldDimensions),
   REQUIRES(FrameInfo),
-  REQUIRES(GlobalOpponentsModel),
+  REQUIRES(ObstacleModel),
+  REQUIRES(RobotPose),
+  REQUIRES(TeamData),
   REQUIRES(GameState),
   PROVIDES(PassEvaluation),
   DEFINES_PARAMETERS(
   {,
     (float)(0.01f) minValue, /**< Minimum probability of a successful pass in the worst situation possible. */
-    (float)(1400.f) opponentDistToTargetThreshold, /**< Distance to the closest opponent for the pass target to be considered free */
-    (float)(1000.f) opponentDistToLineThreshold, /**< Distance to the closest opponent for the pass line to be considered free */
+    (float)(1900.f) opponentDistToTargetThreshold, /**< Distance to the closest opponent for the pass target to be considered free */
+    (float)(1500.f) opponentDistToLineThreshold, /**< Distance to the closest opponent for the pass line to be considered free */
     (float)(4000.f) distancePenaltyThresholdPlaying, /**< if the point is further away than this the distance rating is below 1 */
     (float)(6000.f) distancePenaltyThresholdFreeKick, /**< if the point is further away than this the distance rating is below 1 */
     (float)(1000.f) distancePenaltyDeviation, /**< standard deviation for the upper limit of the distance */
-    (float)(800.f) distToBoundaryThreshold, /**< Distance to the closest field boundary for the ball to stay within the field */
-    (float)(200.f) opponentShiftToBall, /**< Shift each opponent's position this far in the direction of the ball, assuming their orientation */
-    (float)(100.f) obstacleBlockingRadius, /**< Radius of opponents in which a pass would definitely fail */
+    (float)(1400.f) distToBoundaryThreshold, /**< Distance to the closest field boundary for the ball to stay within the field */
+    (float)(200.f) opponentShiftToBase, /**< Shift each opponent's position this far in the direction of the base, assuming their orientation */
+    (float)(300.f) obstacleBlockingRadius, /**< Radius of opponents in which a pass would definitely fail */
     (float)(100.f) cellSize, /**< Size of each grid cell in mm on the field, lower number results in higher resolution for the heatmap */
     (Vector2f)(0.f, 500.f) goalPostShift, /**< Shift the blocking area of a teammate's goal shot on the y axis away from the goal posts */
     (unsigned char)(255) heatmapAlpha, /**< Transparency of the heatmap between 0 (invisible) and 255 (opaque) */
@@ -63,11 +66,11 @@ private:
   bool calcShotLineFree = true;
   bool calcShotDistance = true;
   unsigned int lastUpdateParameters;
-  Vector2f ballOnField;
-  Angle ballToLeftGoalPost;
-  Angle ballToRightGoalPost;
-  Angle ballToLeftGoalArea;
-  Angle ballToRightGoalArea;
+  Vector2f basePositionOnField;
+  Angle baseToLeftGoalPost;
+  Angle baseToRightGoalPost;
+  Angle baseToLeftGoalArea;
+  Angle baseToRightGoalArea;
   Vector2f leftGoalPost = Vector2f(theFieldDimensions.xPosOpponentGoalPost, theFieldDimensions.yPosLeftGoal - theBallSpecification.radius * 2.f);
   Vector2f rightGoalPost = Vector2f(theFieldDimensions.xPosOpponentGoalPost, theFieldDimensions.yPosRightGoal + theBallSpecification.radius * 2.f);
   Vector2f opponentFieldCorner = Vector2f(theFieldDimensions.xPosOpponentGroundLine, theFieldDimensions.yPosLeftSideline);
@@ -78,15 +81,17 @@ private:
 
   /**
    * Estimates the probability that a pass from the current ball position to the given target position would be successful, taking into account the known obstacles.
+   * @param baseOnField The target position to pass from.
    * @param pointOnField The target position to pass to.
    * @return The estimated probability of a successful pass.
    */
-  float getRating(const Vector2f& pointOnField);
+  float getRating(const Vector2f& baseOnField, const Vector2f& targetOnField);
 
   /**
    * Updates the member variables related to the ball and obstacles only once per frame.
+   * @param baseOnField The target position to pass from.
    */
-  void updateParameters();
+  void updateParameters(const Vector2f& baseOnField);
 
   /**
    * Updates minimum distance of the obstacles to the target itself as well as the line from the ball to the target.
diff --git a/Src/Modules/BehaviorControl/SkillBehaviorControl/Options/HandleCatchBall.h b/Src/Modules/BehaviorControl/SkillBehaviorControl/Options/HandleCatchBall.h
index 6a86544480..6a6390a094 100644
--- a/Src/Modules/BehaviorControl/SkillBehaviorControl/Options/HandleCatchBall.h
+++ b/Src/Modules/BehaviorControl/SkillBehaviorControl/Options/HandleCatchBall.h
@@ -13,17 +13,35 @@ option(HandleCatchBall)
   {
     transition
     {
-      if(!theFieldBall.interceptBall ||
-         theInterceptBallSkill.isDone())
+      const float ballDistance = theFieldBall.positionRelative.norm();
+      if(!theFieldBall.interceptBall && theFieldBall.positionRelative.squaredNorm() > sqr(750.f))
         goto noCatch;
+      if(!theFieldBall.interceptBall || !theFieldBall.ballWasSeen() ||
+         ballDistance < 300.f ||
+         BallPhysics::timeForDistance(theBallModel.estimate.velocity, theFieldBall.positionRelative.norm() - 300.f, theBallSpecification.friction) < 0.1)
+        goto backWalking;
     }
     action
     {
-      unsigned interceptionMethods = bit(Interception::stand) | bit(Interception::walk);
+      unsigned interceptionMethods = bit(Interception::walk);
       // Removed for 2021 competitions:
       // if(!theDamageConfigurationBody.noFieldGenuflect && theFrameInfo.getTimeSince(_context.behaviorStart) > genuflectDelay && theMotionInfo.executedPhase == MotionPhase::stand)
       //   interceptionMethods |= bit(Interception::genuflectStandDefender);
       theInterceptBallSkill({.interceptionMethods = interceptionMethods});
     }
   }
+
+  state(backWalking)
+  {
+    transition
+    {
+      if(state_time > 300)
+        goto noCatch;
+    }
+    action
+    {
+      theWalkAtRelativeSpeedSkill({ 0.f, -0.3f, 0.f });
+      theLookAtBallSkill();
+    }
+  }
 }
diff --git a/Src/Modules/BehaviorControl/SkillBehaviorControl/Options/HandleGameState.h b/Src/Modules/BehaviorControl/SkillBehaviorControl/Options/HandleGameState.h
index cbecd56970..60758c7016 100644
--- a/Src/Modules/BehaviorControl/SkillBehaviorControl/Options/HandleGameState.h
+++ b/Src/Modules/BehaviorControl/SkillBehaviorControl/Options/HandleGameState.h
@@ -32,6 +32,13 @@ option(HandleGameState)
   {
     action
     {
+      if(!Global::getSettings().scenario.starts_with("DynamicBallHandlingChallenge"))
+      {
+        const std::string errorMessage = "Attention: The code on this branch should be used with the correct scenario for the Dynamic Ball Handling Challenge only.";
+        theSaySkill({.text = errorMessage});
+        FAIL(errorMessage);
+      }
+
       theLookAtAnglesSkill({.pan = 0_deg,
                             .tilt = 0_deg,
                             .speed = 150_deg});
@@ -60,18 +67,8 @@ option(HandleGameState)
   {
     action
     {
-      if(!theLibDemo.isOneVsOneDemoActive)
-      {
-        const Vector2f targetOnField = theGameState.isPenaltyKick() ?
-                                       Vector2f(theGameState.isForOwnTeam() ?
-                                                theFieldDimensions.xPosOpponentPenaltyMark :
-                                                theFieldDimensions.xPosOwnPenaltyMark, 0.f) :
-                                       Vector2f::Zero();
-        theLookAtPointSkill({.target = (Vector3f() << theRobotPose.inverse() * targetOnField, theBallSpecification.radius).finished()});
-      }
-      else
-        theLookActiveSkill({.ignoreBall = true});
-      theStandSkill({.high = true});
+      theLookActiveSkill({.ignoreBall = true});
+      theStandSkill({.high = false});
     }
   }
 
diff --git a/Src/Modules/BehaviorControl/SkillBehaviorControl/SkillBehaviorControl.cpp b/Src/Modules/BehaviorControl/SkillBehaviorControl/SkillBehaviorControl.cpp
index e72bacd5e3..4673eafa3c 100644
--- a/Src/Modules/BehaviorControl/SkillBehaviorControl/SkillBehaviorControl.cpp
+++ b/Src/Modules/BehaviorControl/SkillBehaviorControl/SkillBehaviorControl.cpp
@@ -34,6 +34,7 @@ void SkillBehaviorControl::update(ActivationGraph&)
   theBehaviorStatus.walkingTo = Vector2f::Zero();
   theBehaviorStatus.speed = 0.f;
   theBehaviorStatus.shootingTo.reset();
+  theBehaviorStatus.lastKickTimestamp = theMotionInfo.lastKickTimestamp;
 
   theArmMotionRequest.armMotion[Arms::left] = ArmMotionRequest::none;
   theArmMotionRequest.armMotion[Arms::right] = ArmMotionRequest::none;
@@ -142,9 +143,12 @@ void SkillBehaviorControl::executeRequest()
         if((theFieldBall.ballWasSeen(7000) || theTeammatesBallModel.isValid) && theFieldBall.isBallPositionConsistentWithGameState())
         {
           theWalkToPointObstacleSkill({.target = theRobotPose.inverse() * theSkillRequest.target,
+                                       .reduceWalkingSpeed = false,
                                        .rough = theGameState.isGoalkeeper(),
                                        .disableObstacleAvoidance = theGameState.isGoalkeeper(),
-                                       .targetOfInterest = theFieldBall.recentBallPositionRelative()}); // TODO: set the right parameters and occasionally use WalkPotentialField
+                                       .targetOfInterest = theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) > 10000 ?
+                                                           std::optional<Vector2f>{theFieldBall.recentBallPositionRelative()} :
+                                                           std::nullopt}); // TODO: set the right parameters and occasionally use WalkPotentialField
           if(theMotionInfo.isMotion(MotionPhase::stand))
             theLookActiveSkill({.withBall = true});
           else
@@ -155,6 +159,7 @@ void SkillBehaviorControl::executeRequest()
         else
         {
           theWalkToPointObstacleSkill({.target = theRobotPose.inverse() * theSkillRequest.target,
+                                       .reduceWalkingSpeed = false,
                                        .rough = theGameState.isGoalkeeper(),
                                        .disableObstacleAvoidance = theGameState.isGoalkeeper()}); // TODO: set the right parameters and occasionally use WalkPotentialField
           theLookActiveSkill({.withBall = true});
diff --git a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/Ball/InterceptBall.cpp b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/Ball/InterceptBall.cpp
index 1d15f0ddd6..148bb2e426 100644
--- a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/Ball/InterceptBall.cpp
+++ b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/Ball/InterceptBall.cpp
@@ -164,10 +164,6 @@ class InterceptBallImpl : public InterceptBallImplBase
     {
       transition
       {
-        if(!(theFieldBall.ballWasSeen(300) &&
-             between<float>(theFieldBall.timeUntilIntersectsOwnYAxis, 0.1f, 3.5f)))
-          goto targetStand;
-
         ASSERT(p.interceptionMethods != 0);
         const float positionIntersectionYAxis = theFieldBall.intersectionPositionWithOwnYAxis.y();
 
diff --git a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/PassToTeammate.cpp b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/PassToTeammate.cpp
index 6b1edd3251..a10acc298e 100644
--- a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/PassToTeammate.cpp
+++ b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/PassToTeammate.cpp
@@ -10,6 +10,7 @@
 #include "Debugging/DebugDrawings.h"
 #include "Debugging/DebugDrawings3D.h"
 #include "Representations/BehaviorControl/FieldBall.h"
+#include "Representations/BehaviorControl/ExecutedPasses.h"
 #include "Representations/BehaviorControl/ExpectedGoals.h"
 #include "Representations/BehaviorControl/PassEvaluation.h"
 #include "Representations/BehaviorControl/Skills.h"
@@ -41,6 +42,7 @@ SKILL_IMPLEMENTATION(PassToTeammateImpl,
   CALLS(LookLeftAndRight),
   REQUIRES(BallSpecification),
   REQUIRES(DamageConfigurationBody),
+  REQUIRES(ExecutedPasses),
   REQUIRES(ExpectedGoals),
   REQUIRES(ExtendedGameState),
   REQUIRES(FieldBall),
@@ -57,33 +59,27 @@ SKILL_IMPLEMENTATION(PassToTeammateImpl,
   {,
     (std::vector<KickInfo::KickType>) allowedKicks, /**< The list of available kicks for passing */
     (bool) doSpecialKickChecks, /**< Makes kicks unavailable for certain situations (should be disabled when only a few kicks are allowed) */
-    (float) minKickLengthForLong, /**< Distance to pass target must be greater than this for using the forwardFastLong during own goal kicks */
     (float) ratingThreshold, /**< During kick-off and free kicks wait with kicking the ball if the teammate's pass position rating is worse */
     (float) passAheadDistance, /**< Shift the pass target by this distance in the direction of the goal */
+    (float) passTargetDistanceMinimum, /**< Clip pass target to this minimum distance to the ball */
     (Angle) minAngleOffset, /**< Kick angle must deviate more than this from the next obstacle range in the sector wheel. This is half the minimum angular range of a free sector that the ball can be kicked through */
     (Angle) maxAngleOffset, /**< Kick angle must not deviate more than this from the original angle to the target. This is half the angular range in which free sectors are considered */
     (Angle) maxAngleOffsetBehind, /**< maxAngleOffset when the ball is passed on the own goal side (instead of the opponent's goal side) of the pass target (from the perspective of the ball) */
     (Angle) maxPrecisionOffset, /**< Precision range for kick angle may not be more than +- this offset */
-    (Vector2f) waitingPositionOffset, /**< Distance of waiting position to the kick position offset to the ball */
     (float) targetOffsetToFieldBorder, /**< Pass target's minimum distance to field border, to prevent ball from rolling out of its boundary */
-    (int) timeLeftToAdjust, /**< Time left until the game state ends below which the robot will choose the final pass target and adjust itself accordingly behind the ball before executing the pass */
-    (int) minTimeWaiting, /**< Stand still for a minimum of this many seconds */
-    (int) maxTimeWaiting, /**< Stand still for a maximum of this many seconds */
     (float) maxTimeWaitingFactor, /**< Maximum waiting time when multiplied with the time left in this half of the game */
-    (float) kickRangeOffset, /**< Minimum and maximum range of the forwardFastPass is extended by this */
     (float) averageKickExecutionTime, /**< Time it takes to perform most kick motions (from the KickInfo) */
     (Vector2f) averageKickBallOffset, /**< Position behind the ball needed to perform most kick motions (from the KickInfo) */
     (float) ignoreObstaclesThreshold, /**< Obstacle avoidance will be disabled when this close to the waiting position */
     (float) ignoreDynamicObstaclesThreshold, /**< Obstacle avoidance will be disabled when this close to the waiting position */
+    (float) standKickObstacleDistanceTreshold, /**< Maximum distance to the closest obstacle at which to use inwalk kicks exclusively. */
     (bool) lookAhead, /**< Estimate the teammate's position into the future */
     (float) maxLookAheadTime, /**< When lookAhead, estimate the teammate's position a maximum of this many milliseconds into the future */
     (Rangef) interceptionDistanceThreshold, /**< Thresholds to check whether or not the receiver is close enough to the kick target to intercept the ball in time */
     (Rangef) targetDistanceScale, /**< Length thresholds for a linear interpolation of the pass distance to the above parameter */
     (float) minRating,
-
-    (Angle) maxHeadAngle, /**< maximum angle when looking around when waiting before executing a free kick */
-    (Angle) headSpeed, /**< angle speed when looking around when waiting before executing a free kick*/
-    (Angle) headTilt, /**< tilt of the head when looking around when waiting before executing a free kick */
+    (Angle) rotationThresholdNear, /** < Threshold for the angle to the target pose for the robot to be considered close to it. */
+    (float) translationThresholdNear, /** < Threshold for the distance to the target pose regarding both axis (x, y) for the robot to be considered close to it. */
   }),
 });
 
@@ -100,6 +96,8 @@ class PassToTeammateImpl : public PassToTeammateImplBase
   KickInfo::KickType lastKickType = KickInfo::numOfKickTypes;
   int lastPassTarget = -1;
   Vector2f lastKickTarget = Vector2f::Zero();
+  unsigned timeWhenFarFromTargetPose = 0;
+  bool passToLeftSide = true;
   const Vector2f opponentGoal = Vector2f(theFieldDimensions.xPosOpponentGroundLine, 0.f);
   const Vector2i bottomLeftCorner = Vector2i(theFieldDimensions.xPosOwnGroundLine + targetOffsetToFieldBorder,
                                              theFieldDimensions.yPosRightSideline + targetOffsetToFieldBorder);
@@ -124,64 +122,32 @@ class PassToTeammateImpl : public PassToTeammateImplBase
 
     common_transition
     {
-      // In regular playing, always kick the ball immediately (without waiting).
-      if(!isFreeKick() && !isKickOff())
-      {
-        if(teammate)
-          goto kick;
-        else
-          goto abort;
-      }
-      // When a free kick started this frame, reset member variables and take the transitions from the initial state.
-      if(theGameState.state != theExtendedGameState.stateLastFrame)
-      {
-        reset();
-        if(canWait(minTimeWaiting + timeLeftToAdjust))
-          goto walk;
-        else
-          goto adjust;
-      }
+      if(teammate)
+        goto kick;
+      else
+        goto walk;
     }
 
-    // When the skill started this frame, reset member variables and decide whether to wait or adjust before executing the kick.
     initial_state(initial)
     {
       transition
       {
         reset();
-        if(canWait(minTimeWaiting + timeLeftToAdjust))
-          goto walk;
+        if(teammate)
+          goto kick;
         else
-          goto adjust;
+          goto walk;
       }
     }
 
     // Walk to the waiting position while calculating the kick target once.
     state(walk)
     {
-      transition
-      {
-        // When the waiting position is reached, wait behind the ball, if there's time to stand, otherwise adjust before executing the kick.
-        if(theWalkToPointSkill.isDone() &&
-           canWait(minTimeWaiting + timeLeftToAdjust))
-          goto wait;
-        if(!canWait(timeLeftToAdjust))
-          goto adjust;
-      }
-
       action
       {
-        // Calculate the kick target and kick type in the first frame of this state and when the passed-to player changed.
-        if(state_time == 0 || !keepLastKickTarget())
-        {
-          updateKickTarget();
-          lastKickType = selectKickType();
-        }
-        else
-          updateKickParameters();
         const Pose2f targetPose = calculateWaitingPose();
         theWalkToPointSkill({.target = targetPose,
-                             .reduceWalkingSpeed = false,
+                             .reduceWalkingSpeed = true,
                              .rough = targetPose.translation.squaredNorm() <= sqr(ignoreObstaclesThreshold),
                              .disableObstacleAvoidance = targetPose.translation.squaredNorm() <= sqr(ignoreDynamicObstaclesThreshold),
                              .disableAvoidFieldBorder = true});
@@ -189,75 +155,6 @@ class PassToTeammateImpl : public PassToTeammateImplBase
       }
     }
 
-    // Stand at the waiting position behind the ball as long as there's is still enough time left and the pass situation could improve.
-    state(wait)
-    {
-      transition
-      {
-        updateTargetRating();
-        const bool waitedTooLong = !canWait(timeLeftToAdjust) ||
-                                   state_time > maxTimeWaiting;
-        const bool waitedLongEnough = state_time > minTimeWaiting;
-        const bool passAvailabilityChanged = !keepLastKickTarget() ||
-                                             (isAngleFree && isTargetFree);
-        if(waitedTooLong || (passAvailabilityChanged && waitedLongEnough))
-          goto adjust;
-      }
-
-      action
-      {
-        theStandSkill();
-
-        // TODO: maybe split into two states
-        // TODO: compute a angle range to not look outside the field
-        // TODO: decide the side in which to look first (maybe based on y coordinate (hysteresis needed))
-        if(state_time < 4 * maxHeadAngle.toDegrees() / headSpeed.toDegrees() * 1000)
-          theLookLeftAndRightSkill({.startLeft = true,
-                                    .maxPan = maxHeadAngle,
-                                    .tilt = headTilt,
-                                    .speed = headSpeed});
-        else
-          theLookActiveSkill({.withBall = false});
-        lastKickType = KickInfo::numOfKickTypes;
-      }
-    }
-
-    // Calculate the kick target once, adjust to the new waiting position and keep walking, then execute the kick, if the teammate is available for a pass.
-    state(adjust)
-    {
-      transition
-      {
-        // When the ideal orientation is reached and the trajectory is not blocked by obstacles, execute the kick.
-        // Note that we did not check for isAngleFree before executing the kick in setplays at RoboCup 2022. This led to risky passes that were sometimes successful and sometimes intercepted by opponents.
-        if(theWalkToPointSkill.isDone())
-        {
-          if(!isAngleFree || !teammate)
-            goto abort; // TODO: Should the robot wait instead?
-          goto kick;
-        }
-      }
-
-      action
-      {
-        // Calculate the kick target and kick type in the first frame of this state and when the passed-to player changed.
-        if(state_time == 0 || !keepLastKickTarget())
-        {
-          updateKickTarget();
-          lastKickType = selectKickType();
-        }
-        else
-          updateKickParameters();
-        const Pose2f targetPose = calculateWaitingPose();
-        theWalkToPointSkill({.target = targetPose,
-                             .reduceWalkingSpeed = false,
-                             .rough = targetPose.translation.squaredNorm() <= sqr(ignoreObstaclesThreshold),
-                             .disableObstacleAvoidance = targetPose.translation.squaredNorm() <= sqr(ignoreDynamicObstaclesThreshold),
-                             .disableStanding = true,
-                             .disableAvoidFieldBorder = true});
-        theLookActiveSkill({.withBall = true});
-      }
-    }
-
     // Execute the kick immediately.
     state(kick)
     {
@@ -276,12 +173,44 @@ class PassToTeammateImpl : public PassToTeammateImplBase
           updateKickParameters();
         // Set the most suitable kick and its parameters, then execute it.
         auto kickType = selectKickType();
-        const auto alignPrecisely = (kickType == KickInfo::walkForwardsRightLong ||
-                                     kickType == KickInfo::walkForwardsLeftLong ||
-                                     kickType == KickInfo::walkTurnRightFootToLeft ||
-                                     kickType == KickInfo::walkTurnLeftFootToRight) ?
-                                    KickPrecision::precise :
-                                    KickPrecision::notPrecise;
+        // Be precise for walk kicks.
+        auto alignPrecisely = (kickType == KickInfo::walkForwardsRightLong ||
+                               kickType == KickInfo::walkForwardsLeftLong ||
+                               kickType == KickInfo::walkTurnRightFootToLeft ||
+                               kickType == KickInfo::walkTurnLeftFootToRight) ?
+                              KickPrecision::precise :
+                              KickPrecision::notPrecise;
+
+        const Pose2f kickPose = Pose2f(kickAngle, theFieldBall.interceptedEndPositionRelative)
+                                .rotate(theKickInfo[kickType].rotationOffset)
+                                .translate(theKickInfo[kickType].ballOffset);
+        const bool isCloseToKickPose = std::abs(kickPose.rotation) < rotationThresholdNear &&
+                                       std::abs(kickPose.translation.x()) < translationThresholdNear &&
+                                       std::abs(kickPose.translation.y()) < translationThresholdNear;
+        // Warning: This only works for the Dynamic Ball Handling Challenge where there are no setplays (and therefore the states other than 'kick' are unused in this option).
+        if(!isCloseToKickPose)
+          timeWhenFarFromTargetPose = theFrameInfo.time;
+
+        const Pose2f estimatedReceiverPose(teammate->pose.rotation,
+                                           teammate->getFuturePosition(1000));
+        const Angle estimatedTargetRotation = KickSelection::calculateTargetRotation(theFieldBall.interceptedEndPositionOnField,
+                                              kickTarget,
+                                              opponentGoal);
+        const Pose2f estimatedTargetPose(estimatedTargetRotation, kickTarget);
+        const Pose2f relativeReceiverToTargetPose(estimatedTargetPose - estimatedReceiverPose);
+        const bool isReceiverCloseToTargetPose = std::abs(relativeReceiverToTargetPose.rotation) < rotationThresholdNear &&
+                                                 std::abs(relativeReceiverToTargetPose.translation.x()) < translationThresholdNear &&
+                                                 std::abs(relativeReceiverToTargetPose.translation.y()) < translationThresholdNear;
+
+        // Reduce alignment precision to perform the kick faster, when an opponent is approaching or too much time was wasted aligning behind the ball.
+        if(isOpponentNearBall() ||
+           (timeWhenFarFromTargetPose != 0 &&
+            theFrameInfo.getTimeSince(timeWhenFarFromTargetPose) >= (theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) > 15000 ? 2000 : 5000)))
+          alignPrecisely = KickPrecision::justHitTheBall;
+        else if(!isReceiverCloseToTargetPose)
+          alignPrecisely = KickPrecision::forceWait;
+        // TODO: Add hysteresis for alignPrecisely?
+
         const bool preStepAllowed = !(kickType == KickInfo::walkForwardsLeft ||
                                       kickType == KickInfo::walkForwardsRight);
         // TODO: Opponents running into the planned trajectory can regularly (unintentionally) block and intercept the ball, because the kick angle is not adjusted in the two'ish seconds it takes the robot to go to the ball and kick.
@@ -291,6 +220,9 @@ class PassToTeammateImpl : public PassToTeammateImplBase
                                  .length = kickLength,
                                  .preStepAllowed = preStepAllowed,
                                  .turnKickAllowed = preStepAllowed,
+                                 .speed = (theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) < 6000 ?
+                                           Pose2f(0.7f, 0.7f, 0.7f) :
+                                           Pose2f(1.f, 1.f, 1.f)),
                                  .directionPrecision = precisionRange});
         thePassTargetSkill({.passTarget = p.playerNumber,
                             .ballTarget = theRobotPose.inverse() * kickTarget});
@@ -313,6 +245,24 @@ class PassToTeammateImpl : public PassToTeammateImplBase
     draw();
   }
 
+  bool isOpponentNearBall() const
+  {
+    const Vector2f& ballPositionOnField = theFieldBall.interceptedEndPositionOnField;
+    // Calculates the angular sectors of the known opponents from the obstacle model
+    // TODO: This should be optimized later, because this is calculated twice per frame.
+    const std::list<SectorWheel::Sector>& sectors = calculateObstacleSectors(ballPositionOnField);
+    const auto isCloserObstacle = [](const SectorWheel::Sector& a,
+                                     const SectorWheel::Sector& b)
+    {
+      return a.distance <= b.distance &&
+             a.type == SectorWheel::Sector::obstacle;
+    };
+    const auto closestSector = std::ranges::min_element(sectors, isCloserObstacle);
+    // Don't use standing kicks in this case.
+    return closestSector != sectors.cend() &&
+           closestSector->distance <= standKickObstacleDistanceTreshold;
+  }
+
   // Check whether or not there is still enough time left to wait this many milliseconds during any restart in play (free kick, corner kick, goal kick, kick-in, kick-off).
   // TODO: Rewrite this to calculate a continuous time to wait instead of a hard decision to wait ("yes" or "no") the predefined time.
   bool canWait(const int timeToWait) const
@@ -327,7 +277,6 @@ class PassToTeammateImpl : public PassToTeammateImplBase
            timeUntilHalfEnds * maxTimeWaitingFactor > timeToWait;
   };
 
-
   // Find the player to which the ball should be passed. Note that this skill can be called with an invalid pass target (e.g. p.playerNumber == 0) to utilize the waiting states during setplays. Therefore, no check wether or not the teammate was be found is required after this loop.
   void setTeammateFromParameters(const PassToTeammate& p)
   {
@@ -355,21 +304,14 @@ class PassToTeammateImpl : public PassToTeammateImplBase
   // Calculate the target pose in robot-relative coordinates for waiting behind the ball to minimize adjustment steps when executing the kick later on.
   Pose2f calculateWaitingPose() const
   {
-    // Use parameters from the kick info to find the preferred waiting position behind the ball.
-    const Angle kickRotationOffset = lastKickType != KickInfo::numOfKickTypes ?
-                                     theKickInfo[lastKickType].rotationOffset :
-                                     0_deg;
-    const Vector2f kickBallOffset = waitingPositionOffset + (lastKickType != KickInfo::numOfKickTypes ?
-                                                             theKickInfo[lastKickType].ballOffset :
-                                                             Vector2f::Zero());
-    return Pose2f(kickAngle, theFieldBall.interceptedEndPositionRelative).rotate(kickRotationOffset).translate(kickBallOffset);
+    return Pose2f(-theRobotPose.rotation, theRobotPose.inverse() * (theFieldBall.interceptedEndPositionOnField + Vector2f(-300.f, 0.f)));
   }
 
-
   void updateKickTarget()
   {
     const Vector2f& ballPositionOnField = theFieldBall.interceptedEndPositionOnField;
     kickTarget = teammate ? (ballPositionOnField + calculateTeammateAngle()) : opponentGoal;
+    // TODO: This clipping is wrong, because it could be in a blocked sector.
     Geometry::clipPointInsideRectangle(bottomLeftCorner, topRightCorner, kickTarget);
     updateTargetRating();
     updateKickParameters();
@@ -382,6 +324,8 @@ class PassToTeammateImpl : public PassToTeammateImplBase
     // Calculates the angular sectors of the known opponents from the obstacle model
     const std::list<SectorWheel::Sector>& sectors = calculateObstacleSectors(ballPositionOnField);
 
+    // TODO: Find a way to calculate the new angle based on the kick target from last frame. Currently, the target angle is jumping a lot.
+
     ASSERT(teammate);
     teammatePosition = teammate->pose.translation;
     if(lookAhead)
@@ -399,13 +343,24 @@ class PassToTeammateImpl : public PassToTeammateImplBase
     // Determine whether the ball should be ideally passed to the left (=counterclockwise) or right (=clockwise) side of the pass target (from the perspective of the ball), so that the ball ends up between the receiver and the opponent's goal.
     const Geometry::Line ballGoalLine(ballPositionOnField, opponentGoal - ballPositionOnField);
     const float distToLine = Geometry::getDistanceToLineSigned(ballGoalLine, teammatePosition);
-    const bool passToLeftSide = distToLine > 0.f;
-    const Vector2f targetPosition = (teammatePosition + (opponentGoal - teammatePosition).normalized(passAheadDistance));
-    float targetDistance = (targetPosition - ballPositionOnField).norm();
+    passToLeftSide = distToLine > 0.f;
+
+    // Note: This condition should only be used for the Dynamic Ball Handling Challenge. It overrides the target position for the first pass of the goalkeeper.
+    const bool overrideFirstPassTarget = theExecutedPasses.number == 0 &&
+                                         theGameState.isGoalkeeper() &&
+                                         theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) <= 15000;
+    const Vector2f targetPosition = overrideFirstPassTarget ?
+                                    Vector2f(theFieldDimensions.centerCircleRadius * 0.5f,
+                                             teammatePosition.y() > 0.f ?
+                                             theFieldDimensions.yPosLeftPenaltyArea :
+                                             theFieldDimensions.yPosRightPenaltyArea) :
+                                    (teammatePosition + (opponentGoal - teammatePosition).normalized(passAheadDistance));
+
+    float targetDistance = std::max(passTargetDistanceMinimum, (targetPosition - ballPositionOnField).norm());
     Angle targetAngle = (targetPosition - ballPositionOnField).angle();
 
     // During kick-off, the target angle will not be modified because obstacles can be ignored (there can not legally be any opponents in the own half).
-    isAngleFree = isKickOff();
+    isAngleFree = isKickOff() || overrideFirstPassTarget;
     // When the initial target angle is blocked, it is shifted to a free sector (not blocked by obstacles) in the direction of the opponent's goal first (ideally placing it in front of the receiver).
     if(!isAngleFree)
     {
@@ -437,16 +392,16 @@ class PassToTeammateImpl : public PassToTeammateImplBase
   void updateTargetRating()
   {
     float interpolatedRatingThreshold = ratingThreshold;
-    const int timeInState = theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted);
-    const int timeInStateLeft = theFrameInfo.getTimeSince(theGameState.timeWhenStateEnds);
     // Linear interpolation of state progress to required pass rating from maximum value to 0.f.
     if(isFreeKick() || isKickOff())
     {
+      const int timeInState = theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted);
+      const int timeInStateLeft = theFrameInfo.getTimeSince(theGameState.timeWhenStateEnds);
       const int totalStateTime = std::max(timeInState - timeInStateLeft, 1);
       const float stateProgress = static_cast<float>(timeInState) / static_cast<float>(totalStateTime);
       interpolatedRatingThreshold *= (1.f - clip(stateProgress, 0.f, 1.f));
     }
-    isTargetFree = thePassEvaluation.getRating(kickTarget) > std::max(interpolatedRatingThreshold, minRating);
+    isTargetFree = thePassEvaluation.getRating(theFieldBall.recentBallPositionOnField(), kickTarget) > std::max(interpolatedRatingThreshold, minRating);
   }
 
   void updateKickParameters()
@@ -465,7 +420,7 @@ class PassToTeammateImpl : public PassToTeammateImplBase
       const Vector2f& obstacleOnField = obstacle.position;
       if(obstacleOnField.x() > (theFieldDimensions.xPosOpponentGroundLine + theFieldDimensions.xPosOpponentGoal) * 0.5f)
         continue;
-      const float obstacleWidth = (obstacle.left - obstacle.right).norm() + 4.f * theBallSpecification.radius;
+      const float obstacleWidth = (obstacle.left - obstacle.right).norm() + 8.f * theBallSpecification.radius;
       const float obstacleDistance = std::sqrt(std::max((obstacleOnField - ballPositionOnField).squaredNorm() - sqr(obstacleWidth / 2.f), 1.f));
       if(obstacleDistance < theBallSpecification.radius)
         continue;
@@ -483,7 +438,7 @@ class PassToTeammateImpl : public PassToTeammateImplBase
     // Rating of diviation of new angle to the original angle.
     const Angle maxAngleDeviation = isIdealSide ? maxAngleOffset : maxAngleOffsetBehind;
     const float offsetRating = mapToRange(targetAngle.diffAbs(candidateAngle), 0_deg, maxAngleDeviation, isIdealSide ? Angle(1.f) : Angle(0.6f), 0_deg);
-    const float positionRating = thePassEvaluation.getRating(targetPosition);
+    const float positionRating = thePassEvaluation.getRating(theFieldBall.recentBallPositionOnField(), targetPosition);
     const float goalRating = theExpectedGoals.getRating(targetPosition);
     const float combinedRating = offsetRating * positionRating * goalRating;
     COMPLEX_DRAWING("skill:PassToTeammate:evaluation")
@@ -623,6 +578,7 @@ class PassToTeammateImpl : public PassToTeammateImplBase
   {
     std::vector<KickInfo::KickType> kicks;
     kicks.reserve(KickInfo::numOfKickTypes);
+    const bool shouldUseInWalkKicks = isOpponentNearBall();
     // Check for each allowed kick whether or not it should be made available in the given situation.
     for(const KickInfo::KickType kickType : allowedKicks)
     {
@@ -630,60 +586,20 @@ class PassToTeammateImpl : public PassToTeammateImplBase
       // Makes some kicks unavailable or even mandatory for certain situations.
       if(doSpecialKickChecks)
       {
+        if((passToLeftSide && kick.kickLeg == Legs::right) ||
+           (!passToLeftSide && kick.kickLeg == Legs::left))
+          continue;
         switch(kickType)
         {
-          case KickInfo::forwardFastRightLong:
-          case KickInfo::forwardFastLeftLong:
-          {
-            // Skip this kick if it requires standing on a weak leg of the robot.
-            if(kick.motion == MotionPhase::kick &&
-               theDamageConfigurationBody.sides[kick.mirror ? Legs::right : Legs::left].weakLeg)
-              continue;
-            // This kick requires standing still and should only be used for goal kicks.
-            if(isGoalKick() && kickLength >= minKickLengthForLong - (kickType == lastKickType ? 400.f : 0.f))
-              return {KickInfo::forwardFastRightLong, KickInfo::forwardFastLeftLong};
-            continue;
-          }
-          case KickInfo::forwardFastRight:
-          case KickInfo::forwardFastLeft:
-          {
-            // Skip this kick if it requires standing on a weak leg of the robot.
-            if(kick.motion == MotionPhase::kick &&
-               theDamageConfigurationBody.sides[kick.mirror ? Legs::right : Legs::left].weakLeg)
-              continue;
-            // This kick requires standing still and should only be used and preferred during any restart in play (free kick, corner kick, goal kick, kick-in) except for kick-offs.
-            if(!isFreeKick() && !isKickOff())
-              continue;
-            // This kick has a high chance of the ball rolling further than planned and therefore should only be used for kicking directly at the receiver.
-            if(canTeammateInterceptBall())
-              return {KickInfo::forwardFastRight, KickInfo::forwardFastLeft};
-            continue;
-          }
           case KickInfo::forwardFastRightPass:
           case KickInfo::forwardFastLeftPass:
           {
-            // Skip this kick if it requires standing on a weak leg of the robot.
-            if(kick.motion == MotionPhase::kick &&
-               theDamageConfigurationBody.sides[kick.mirror ? Legs::right : Legs::left].weakLeg)
+            if(shouldUseInWalkKicks)
               continue;
-            // This kick requires standing still and should only be used and preferred during any restart in play (free kick, corner kick, goal kick, kick-in) except for kick-offs.
-            if(!isFreeKick() && !isKickOff())
-              continue;
-            const float kickRangeExtension = kickRangeOffset + (kickType == lastKickType ? 200.f : 0.f);
-            // This kick should only be used for distances close to the minimum or maximum of it's range.
-            const Rangef minRange(kick.range.min - kickRangeExtension, kick.range.min + kickRangeExtension);
-            const Rangef maxRange(kick.range.max - kickRangeExtension, kick.range.max + kickRangeExtension);
-            if(minRange.isInside(kickLength) ||
-               maxRange.isInside(kickLength))
-              return {KickInfo::forwardFastRightPass, KickInfo::forwardFastLeftPass};
-            continue;
           }
           case KickInfo::walkForwardsRightLong:
           case KickInfo::walkForwardsLeftLong:
           {
-            // This kick should be substituted for the alternative version for kick-offs to prevent the ball from leaving the field.
-            if(isKickOff())
-              continue;
           }
           default:
             break;
@@ -762,6 +678,7 @@ class PassToTeammateImpl : public PassToTeammateImplBase
     lastKickType = KickInfo::numOfKickTypes;
     lastPassTarget = -1;
     lastKickTarget = Vector2f::Zero();
+    timeWhenFarFromTargetPose = 0;
   }
 };
 
diff --git a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/PlayBall.cpp b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/PlayBall.cpp
index e3407433f0..92551ead0b 100644
--- a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/PlayBall.cpp
+++ b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/PlayBall.cpp
@@ -33,8 +33,9 @@ SKILL_IMPLEMENTATION(PlayBallImpl,
   {,
     (float)(500.f) goalPostHandlingAreaRadius,
     (float)(1.2f) goalPostHandlingAreaHysteresisMultiplier,
-    (float)(1000.f) duelMinDistanceToClosest,
+    (float)(600.f) duelMinDistanceToClosest,
     (Angle)(100_deg) duelMinAngleToClosest,
+    (bool)(true) useDuel,
   }),
 });
 
@@ -110,6 +111,9 @@ class PlayBallImpl : public PlayBallImplBase
 
   bool activateDuel() const
   {
+    if(!useDuel)
+      return false;
+
     if((theGameState.isKickOff() || theGameState.isFreeKick()) && theGameState.isForOwnTeam())
       return false;
 
diff --git a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/ReceivePass.cpp b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/ReceivePass.cpp
index d019af9fea..79afdfdb43 100644
--- a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/ReceivePass.cpp
+++ b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/ReceivePass.cpp
@@ -56,6 +56,7 @@ class ReceivePassImpl : public ReceivePassImplBase
     // Walk to the target position and look towards the ball to receive it when it arrives
     const Pose2f passTargetRelative(targetAngle, theRobotPose.inverse() * passTarget);
     theWalkToPointSkill({.target = passTargetRelative,
+                         .reduceWalkingSpeed = false,
                          .targetOfInterest = theFieldBall.recentBallPositionRelative(),
                          .forceSideWalking = false});
     theLookActiveSkill({.withBall = true,
diff --git a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/Zweikampf.cpp b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/Zweikampf.cpp
index 9c82353507..61b46b4f31 100644
--- a/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/Zweikampf.cpp
+++ b/Src/Modules/BehaviorControl/SkillBehaviorControl/Skills/Zweikampf.cpp
@@ -126,6 +126,7 @@ SKILL_IMPLEMENTATION(ZweikampfImpl,
   CALLS(GoToBallAndKick),
   CALLS(LookActive),
   CALLS(WalkToPoint),
+  CALLS(PassTarget),
   REQUIRES(BallModel),
   REQUIRES(BallSpecification),
   REQUIRES(FieldBall),
@@ -195,6 +196,7 @@ class ZweikampfImpl : public ZweikampfImplBase
     Angle kickAngle = 0_deg; /**< Kick direction. */
     float range = -1.f; /**< Kick range. Used to calculate the kick power. */
     TargetType type = TargetType::other; /**< Type of the situation, in which the kick is used. */
+    int passTarget = -1;
     Vector2f lastFieldEndPoint; /**< Ball end position after the kick. */
     bool justHitTheBall = true;
   };
@@ -213,7 +215,7 @@ class ZweikampfImpl : public ZweikampfImplBase
     std::optional<float> rating; /**< Rating of the range. */
     float range = 0.f; /**< The kick range. */
     Vector2f fieldEndPoint;
-    bool isTeammatePass = false;
+    int isTeammatePass = -1;
     bool isTypeSteal = false;
 
     float ratingFunc(const FieldRating& theFieldRating, const int passTarget, const Vector2f& useBallPosition,
@@ -344,6 +346,11 @@ class ZweikampfImpl : public ZweikampfImplBase
                                    .turnKickAllowed = theDuelPose.turnKickAllowed,
                                    .shiftTurnKickPose = theDuelPose.shiftTurnKickPose,
                                    .directionPrecision = theDuelPose.precision});
+
+          // TODO: Zweikampf never checks if the pass goes to the originally requested target :(
+          if(theDuelPose.type == TargetType::pass)
+            thePassTargetSkill({ .passTarget = theDuelPose.passTarget,
+                                 .ballTarget = theRobotPose.inverse() * theDuelPose.lastFieldEndPoint });
         }
         else
         {
@@ -874,6 +881,9 @@ class ZweikampfImpl : public ZweikampfImplBase
         else if((theDuelPose.kickType == KickInfo::walkForwardsLeftAlternative || theDuelPose.kickType == KickInfo::walkForwardsRightAlternative))
           theDuelPose.kickType = theDuelPose.kickType == KickInfo::walkForwardsLeftAlternative ? KickInfo::walkForwardsLeftLong : KickInfo::walkForwardsRightLong;
       }
+      if(theDuelPose.type == TargetType::pass && (theDuelPose.kickType == KickInfo::walkForwardsLeftLong || theDuelPose.kickType == KickInfo::walkForwardsRightLong))
+        theDuelPose.kickType = theDuelPose.kickType == KickInfo::walkForwardsLeftLong ? KickInfo::walkForwardsLeftAlternative : KickInfo::walkForwardsRightAlternative;
+
       theDuelPose.precision = Rangea(0_deg, 0_deg);
 
       timeSinceDoingNothing = theFrameInfo.time;
@@ -922,7 +932,7 @@ class ZweikampfImpl : public ZweikampfImplBase
         }
         borderToMinMax = Rangea(std::min(theDuelPose.kickAngle, borderToMinMax.min),
                                 std::max(theDuelPose.kickAngle, borderToMinMax.max));
-        const Angle searchOffset = theKickInfo[theDuelPose.kickType].walkKickType != WalkKicks::forwardSteal && soonCloseRangeDuel ? 90_deg : 5_deg;
+        const Angle searchOffset = theKickInfo[theDuelPose.kickType].walkKickType != WalkKicks::forwardSteal && soonCloseRangeDuel ? 5_deg : 5_deg;
         precision.max = std::max(0.f, borderToMinMax.limit(theDuelPose.kickAngle + searchOffset) - theDuelPose.kickAngle);
         precision.min = std::min(0.f, borderToMinMax.limit(theDuelPose.kickAngle - searchOffset) - theDuelPose.kickAngle);
       }
@@ -1375,7 +1385,8 @@ class ZweikampfImpl : public ZweikampfImplBase
       return false;
     pose.range = rantingMapVector.ratingMap[bestIndex].range;
     pose.rating += bestRating;
-    pose.type = rantingMapVector.ratingMap[bestIndex].isTeammatePass ? TargetType::pass : pose.type;
+    pose.type = rantingMapVector.ratingMap[bestIndex].isTeammatePass > 0 ? TargetType::pass : pose.type;
+    pose.passTarget = rantingMapVector.ratingMap[bestIndex].isTeammatePass;
     pose.lastFieldEndPoint = rantingMapVector.ratingMap[bestIndex].fieldEndPoint;
 
     if((tooMuchRotationInPass || isTypeStealBall) && pose.type != TargetType::pass)
@@ -1655,7 +1666,6 @@ float ZweikampfImpl::RatingMap::ratingFunc(const FieldRating& theFieldRating, co
 
   this->fieldEndPoint = useBallPosition + direction * std::min(range, rangeForGoal);
   // normal rating
-  bool isTeammatePass = false;
   PotentialValue teammate;
   PotentialValue pvBallNear;
 
@@ -1666,13 +1676,12 @@ float ZweikampfImpl::RatingMap::ratingFunc(const FieldRating& theFieldRating, co
     theFieldRating.getObstaclePotential(ratingField, this->fieldEndPoint.x(), this->fieldEndPoint.y(), false);
     theFieldRating.duelBallNearPotential(pvBallNear, this->fieldEndPoint.x(), this->fieldEndPoint.y(), false);
   }
-  theFieldRating.potentialOverall(teammate, this->fieldEndPoint.x(), this->fieldEndPoint.y(), isTeammatePass, false, passTarget);
+  theFieldRating.potentialOverall(teammate, this->fieldEndPoint.x(), this->fieldEndPoint.y(), this->isTeammatePass, false, passTarget);
   theFieldRating.removeBallNearFromTeammatePotential(teammate, pvBallNear);
   ratingField += teammate;
   ratingField += pvBallNear; // add ball near potentiall after the teammates potential
 
   this->rating = ratingField.value;
-  this->isTeammatePass = isTeammatePass;
 
   return this->rating.value();
 }
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/ActiveRoles/PlayBall.cpp b/Src/Modules/BehaviorControl/StrategyBehaviorControl/ActiveRoles/PlayBall.cpp
index 3400c5490c..e1ccaa8520 100644
--- a/Src/Modules/BehaviorControl/StrategyBehaviorControl/ActiveRoles/PlayBall.cpp
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/ActiveRoles/PlayBall.cpp
@@ -32,6 +32,15 @@ SkillRequest PlayBall::execute(const Agent& self, const Agents& teammates)
 
 SkillRequest PlayBall::smashOrPass(const Agent& self, const Agents& teammates)
 {
+  // Note: This condition should only be used for the Dynamic Ball Handling Challenge. It makes any goal shot attempt impossible (except when there are no teammates), before two consecutive passes have been executed.
+  const bool isGoalShotAllowed = theExecutedPasses.number >= 2;
+
+  const bool delayFirstPass = !isGoalShotAllowed &&
+                              theGameState.isGoalkeeper() &&
+                              theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) < 3000;
+  if(delayFirstPass)
+    return SkillRequest::Builder::passTo(0);
+
   if(p.alwaysShoot)
     return SkillRequest::Builder::shoot();
 
@@ -41,7 +50,7 @@ SkillRequest PlayBall::smashOrPass(const Agent& self, const Agents& teammates)
   // Get the estimated probability of shooting a goal from the current ball position
   // TODO: Use ballEndPosition instead?
   const Vector2f ballPosition = self.pose * self.ballPosition;
-  float maxValue = theExpectedGoals.getRating(ballPosition);
+  float maxValue = isGoalShotAllowed ? theExpectedGoals.getRating(ballPosition) : 0.f;
   float maxPassDistance = p.maxPassDistance;
   if(theGameState.isFreeKick() && theGameState.isForOwnTeam())
   {
@@ -53,7 +62,7 @@ SkillRequest PlayBall::smashOrPass(const Agent& self, const Agents& teammates)
   // Apply the decision penalty when this action is different from the last frame
   if(lastPassTarget > 0)
     maxValue -= decisionPenalty;
-  if(maxValue > p.shootThreshold)
+  if(maxValue > p.shootThreshold && isGoalShotAllowed)
   {
     lastPassTarget = -1;
     return SkillRequest::Builder::shoot();
@@ -75,11 +84,12 @@ SkillRequest PlayBall::smashOrPass(const Agent& self, const Agents& teammates)
     float agentValue = 0.f;
     // Sample and evaluate a given number of positions in a given distance on the line from the agent's current position to the opponent's goal
     const Geometry::Line agentGoalLine(agentPosition, (goalPosition - agentPosition).normalized(p.sampleDistance));
+    const Vector2f ballPosition = theFieldBall.recentBallPositionOnField();
     for(int t = p.sampleSteps.min; t <= p.sampleSteps.max; t++)
     {
       const Vector2f samplePosition = agentGoalLine.base + t * agentGoalLine.direction;
       // The teammate's rating is the estimated probability that the ball would reach the given target position when passed AND the teammate would score a direct goal from the pass target position
-      const float sampleValue = thePassEvaluation.getRating(samplePosition) *
+      const float sampleValue = thePassEvaluation.getRating(ballPosition, samplePosition) *
                                 theExpectedGoals.getRating(samplePosition) *
                                 theExpectedGoals.getOpponentRating(samplePosition);
       if(sampleValue > agentValue)
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/ActiveRoles/PlayBall.h b/Src/Modules/BehaviorControl/StrategyBehaviorControl/ActiveRoles/PlayBall.h
index e225158954..00361f9062 100644
--- a/Src/Modules/BehaviorControl/StrategyBehaviorControl/ActiveRoles/PlayBall.h
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/ActiveRoles/PlayBall.h
@@ -15,21 +15,21 @@ class PlayBall : public ActiveRole
 {
   STREAMABLE(Parameters,
   {,
-    (bool)(false) alwaysShoot,
+    (bool)(false) alwaysShoot, /**< Whether or not passing should be deactivated entirely */
     (bool)(false) ignoreObstacles, /**< Whether or not to call the executeLegacy algorithm instead of the default smashOrPass algorithm */
     (float)(0.8f) shootThreshold, /**< Threshold for the own goal shot rating above which no pass targets are considered */
     (float)(0.15f) passImprovement, /**< Offset to the own goal shot rating, that a teammate's goal shot rating must be better than to be considered as a pass target (only used in executeLegacy algorithm) */
-    (float)(1500.f) minPassDistance, /**< In playing, consider teammates as pass targets that are further away from the current player */
-    (float)(4500.f) maxPassDistance, /**< In playing, consider teammates as pass targets that are within this radius from the current player */
+    (float)(1000.f) minPassDistance, /**< In playing, consider teammates as pass targets that are further away from the current player */
+    (float)(5000.f) maxPassDistance, /**< In playing, consider teammates as pass targets that are within this radius from the current player */
     (float)(6000.f) maxFreeKickDistance, /**< During free kicks, increase maximum pass distance to this */
     (float)(9000.f) maxGoalKickDistance, /**< During goal kicks, increase maximum pass distance to this */
-    (float)(0.1f) minPenalty, /**< Changing the decision to shoot or pass from the previous frame, results in this penalty to the rating */
-    (float)(0.8f) maxPenalty, /**< Minimum decision penalty is scaled up to this maximum penalty with decreasing distance to the ball */
+    (float)(0.05f) minPenalty, /**< Changing the decision to shoot or pass from the previous frame, results in this penalty to the rating */
+    (float)(0.4f) maxPenalty, /**< Minimum decision penalty is scaled up to this maximum penalty with decreasing distance to the ball */
     (float)(300.f) ballDistMinPenalty, /**< Apply only the default penalty if the ball is further away than this */
     (float)(200.f) ballDistMaxPenalty, /**< Maximize the penalty if the ball is closer than this */
-    (float)(0.01f) minRating,
+    (float)(0.f) minRating,
     (bool)(true) lookAhead, /**< Whether or not to estimate the teammate's position into the future towards his communicated target pose (not implemented yet) */
-    (int)(2000) lookAheadTime, /**< If lookAhead is true, then the position of each teammate will be estimated this many milliseconds into the future */
+    (int)(2000) lookAheadTime, /**< If lookAhead is true, then the position of each teammate will be estimated this many milliseconds into the future. Warning: This is not yet implemented. */
     (float)(500.f) sampleDistance, /**< Space between sample positions on the line from the teammate's position to the opponent's goal */
     (Rangei)(-1, 2) sampleSteps, /**< Time step interval to sample the positions on the line from the teammate's position to the opponent's goal */
   });
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Forward.cpp b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Forward.cpp
index 4368f7ff3f..1bc78c81b8 100644
--- a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Forward.cpp
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Forward.cpp
@@ -30,9 +30,38 @@ float Forward::rating(const Vector2f& pos) const
   //normal distribution around the base pose
   const float baseRating = std::exp(-0.5f * (pos - base).squaredNorm() / sqr(p.sigmaBase));
 
-  const float passRating = thePassEvaluation.getRating(pos);
+  //get the rating based on the nearest teammate
+  float distanceRating = 1;
+  if(!theGlobalTeammatesModel.teammates.empty())
+  {
+    float minTeammateDistanceSquared = (pos - theGlobalTeammatesModel.teammates.cbegin()->pose.translation).squaredNorm();
+    for(auto t = ++theGlobalTeammatesModel.teammates.cbegin(); t != theGlobalTeammatesModel.teammates.cend(); t++)
+    {
+      const float d = (pos - t->pose.translation).squaredNorm();
+      if(d < minTeammateDistanceSquared)
+        minTeammateDistanceSquared = d;
+    }
+
+    //better rating far away from teammates
+    distanceRating = 1.f - std::exp(-0.5f * minTeammateDistanceSquared / sqr(p.sigmaTeam));
+  }
+
+  Vector2f origin = theFieldBall.recentBallPositionOnField();
+  // Note: This optimization should only be used for the Dynamic Ball Handling Challenge. It overrides the ball position with the base position for the second pass from the other forward player to this forward player. This effectively assumes that the other forward will pass to this forward that will position accordingly in advance.
+  if(theExecutedPasses.number == 0)
+  {
+    Vector2f otherPassTarget(theFieldDimensions.centerCircleRadius,
+                             base.y() > 0.f ?
+                             theFieldDimensions.yPosRightPenaltyArea :
+                             theFieldDimensions.yPosLeftPenaltyArea);
+    for(const Agent* agent : otherAgents)
+      if(agent->position == Tactic::Position::Type::forward)
+        otherPassTarget = agent->currentPosition;
+    origin = otherPassTarget;
+  }
+  const float passRating = thePassEvaluation.getRating(origin, pos);
   const float goalRating = theExpectedGoals.getRating(pos);
 
   //the focus is on the multiplication term because all ratings need to be good at the same time. The additive term is for avoid getting stuck in large 0 areas where just one of the factors is 0. Sxhould be deleted
-  return passRating * goalRating * baseRating * (1.f - p.addWeight) + (p.addWeight / 3) * (baseRating + goalRating + passRating);
+  return passRating * goalRating * baseRating * distanceRating * (1.f - p.addWeight) + (p.addWeight / 4) * (baseRating + goalRating + passRating + distanceRating);
 }
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Forward.h b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Forward.h
index e484fbf10f..decc0d863c 100644
--- a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Forward.h
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Forward.h
@@ -11,6 +11,7 @@
 
 #include "RatingRole.h"
 #include "Tools/BehaviorControl/KickSelection.h"
+#include "Tools/BehaviorControl/Strategy/Agent.h"
 #include "Math/RingBufferWithSum.h"
 
 class Forward : public RatingRole
@@ -18,6 +19,7 @@ class Forward : public RatingRole
   STREAMABLE(Parameters,
   {,
     (float)(2000.f) sigmaBase, /**< standard deviation for rating dependent on base position */
+    (float)(1000.f) sigmaTeam, /**< standard deviation for rating dependent on distance to teammates */
     (float)(0.85f) startThreshold, /**< the rating has to be at least this much better at the destination (normalized for the target pose) to start moving */
     (float)(0.60f) stopThreshold, /**< if the rating is not at least this much better at the destination (normalized for the target pose) stop moving */
     (float)(0.00001f) addWeight, /**< how much should the individual rating functions be added additionally to the multiplication */
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Midfielder.cpp b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Midfielder.cpp
index d3ba1406ce..4dfb395f50 100644
--- a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Midfielder.cpp
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/Midfielder.cpp
@@ -74,7 +74,7 @@ float Midfielder::rating(const Vector2f& pos) const
   //in case of a free kick we know that we are the attacking team so we can play offensively
   //search for free spaces to receive a pass
   if(theGameState.isFreeKick() && theGameState.isForOwnTeam())
-    return baseRating * thePassEvaluation.getRating(pos) * (p.minGoalRating + (1.f - p.minGoalRating) * theExpectedGoals.getRating(pos));
+    return baseRating * thePassEvaluation.getRating(theFieldBall.recentBallPositionOnField(), pos) * (p.minGoalRating + (1.f - p.minGoalRating) * theExpectedGoals.getRating(pos));
 
   //combine the ratings
   return ballRating * rating * baseRating * borderRating;
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/RatingRole.cpp b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/RatingRole.cpp
index 5a2ff91edf..d66e3040d9 100644
--- a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/RatingRole.cpp
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/RatingRole.cpp
@@ -21,7 +21,7 @@ void RatingRole::preProcess()
   MODIFY("behavior:RatingRole:drawHeatmap", drawHeatmap);
 }
 
-Pose2f RatingRole::position(Side, const Pose2f& basePose, const std::vector<Vector2f>& baseArea, const Agents&)
+Pose2f RatingRole::position(Side, const Pose2f& basePose, const std::vector<Vector2f>& baseArea, const Agents& agents)
 {
   //initialize parameters needs to be done before every thing else!
   if(changedRole)
@@ -30,6 +30,7 @@ Pose2f RatingRole::position(Side, const Pose2f& basePose, const std::vector<Vect
   base = basePose.translation;
   region = baseArea;
   ball = theFieldBall.recentBallPositionOnField();
+  otherAgents = agents;
 
   if(drawHeatmap)
     drawRating();
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/RatingRole.h b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/RatingRole.h
index 022fc60a58..4712f09639 100644
--- a/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/RatingRole.h
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/PositionRoles/RatingRole.h
@@ -12,6 +12,7 @@
 
 #include "Tools/BehaviorControl/Strategy/PositionRole.h"
 #include "Tools/BehaviorControl/KickSelection.h"
+#include "Tools/BehaviorControl/Strategy/Agent.h"
 #include "Math/RingBufferWithSum.h"
 
 class RatingRole : public PositionRole
@@ -85,6 +86,7 @@ protected:
   Vector2f base;
   std::vector<Vector2f> region;
   Vector2f ball;
+  Agents otherAgents;
 
   bool drawHeatmap = false;
 
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDefender.cpp b/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDefender.cpp
new file mode 100644
index 0000000000..156396120e
--- /dev/null
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDefender.cpp
@@ -0,0 +1,226 @@
+/**
+ * @file StrategyBehaviorControlDBHDefender.cpp
+ *
+ * This file implements a module that determines the strategy of the team.
+ *
+ * @author Yannik Meinken
+ * @author Lars Bredereke
+ */
+
+#include "StrategyBehaviorControlDBHDefender.h"
+#include "Debugging/DebugDrawings.h"
+#include "Math/BHMath.h"
+
+MAKE_MODULE(StrategyBehaviorControlDBHDefender);
+
+void StrategyBehaviorControlDBHDefender::update(SkillRequest& skillRequest)
+{
+  DECLARE_DEBUG_DRAWING("Strategy:path3", "drawingOnField");
+  DECLARE_DEBUG_DRAWING("Strategy:mark2", "drawingOnField");
+  if(theGameState.playerState != GameState::active ||
+     theGameState.isPenaltyShootout() || theGameState.isInitial() || theGameState.isReady() || theGameState.isFinished())
+    skillRequest = SkillRequest::Builder::empty();
+  else if(theGameState.isSet())
+    skillRequest = SkillRequest::Builder::stand();
+  else if(theGameState.isPlaying())
+    skillRequest = behave();
+}
+
+SkillRequest StrategyBehaviorControlDBHDefender::behave()
+{
+  const float distanceToBall = (theRobotPose.translation - theFieldBall.recentBallPositionOnField()).norm();
+
+  switch(theGameState.playerNumber)
+  {
+    case 1:
+      if(theFieldBall.ballWasSeen(300) &&
+         theFieldBall.isRollingTowardsOwnGoal &&
+         theFieldBall.positionRelative.squaredNorm() < sqr(3000.f))
+      {
+        const float interceptY = clip(theFieldBall.intersectionPositionWithOwnYAxis.y(), theFieldDimensions.yPosRightGoal + 150.f, theFieldDimensions.yPosLeftGoal - 150.f);
+        return SkillRequest::Builder::walkTo(Pose2f(theFieldDimensions.xPosOwnGroundLine, interceptY));
+      }
+      if(theFieldBall.ballWasSeen(5000))
+      {
+        float positionY = mapToRange(theFieldBall.recentBallPositionOnField().y(), theFieldDimensions.yPosRightSideline, theFieldDimensions.yPosLeftSideline, theFieldDimensions.yPosRightGoal + 150.f, theFieldDimensions.yPosLeftGoal - 150.f);
+        positionY /= (theFieldBall.positionRelative.norm() / 2000.f);
+        return SkillRequest::Builder::walkTo(Pose2f(theFieldDimensions.xPosOwnGroundLine, positionY));
+      }
+      return SkillRequest::Builder::walkTo(Pose2f(theFieldDimensions.xPosOwnGroundLine, 0.f));
+    case 3:
+    {
+      if(theFieldBall.timeSinceBallWasSeen > ballSearchDelay && !theFieldBall.teammatesBallIsValid)
+      {
+        if(!ballFound && theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) < ballStillOnSpot)
+          return SkillRequest::Builder::observe(Vector2f(theFieldDimensions.xPosOpponentPenaltyMark, 0.f));
+        return searchBall();
+      }
+      timeBallSearchStarted = 0;
+      ballFound = true;
+      // position to intercept the first pass as long as the ball doesn't leave the opponents half
+      if(distanceToBall < 1500.f && theFieldBall.recentBallPositionOnField().x() > 0.f)
+        return kickBall();
+
+      if(theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) < decideMirroredInterval)
+        return SkillRequest::Builder::walkTo(Pose2f(theFieldDimensions.xPosOpponentPenaltyMark, 0));
+
+      Teammate number2;
+      for(Teammate t : theTeamData.teammates)
+      {
+        if(t.number == 2)
+        {
+          number2 = t;
+          break;
+        }
+      }
+
+      mirrored = number2.theRobotPose.translation.y() > 0;
+
+      Geometry::Line line(theFieldBall.recentBallEndPositionOnField(), theFieldBall.recentBallEndPositionOnField() - Vector2f(0.f, (mirrored ? -1875.f : 1875.f)));
+      Vector2f pointOnLine = Geometry::getOrthogonalProjectionOfPointOnLine(line, theRobotPose.translation);
+      Vector2f dest = pointOnLine + (theFieldBall.recentBallEndPositionOnField() - pointOnLine) *  ballWeight / (Geometry::distance(theRobotPose.translation, pointOnLine));
+      dest = dest.x() > theFieldBall.recentBallEndPositionOnField().x() ? theFieldBall.recentBallEndPositionOnField() : dest;
+      CROSS("Strategy:path3", dest.x(), dest.y(), 30, 3, Drawings::solidPen, ColorRGBA::red);
+      LINE("Strategy:path3", 0.f, mirrored ? -1875 : 1875.f, theFieldBall.recentBallEndPositionOnField().x(), theFieldBall.recentBallEndPositionOnField().y(), 3, Drawings::dashedPen, ColorRGBA::red);
+      if(dest.x() > safetyDistanceToMid)
+        return SkillRequest::Builder::walkTo(Pose2f((theFieldBall.recentBallEndPositionOnField() - dest).angle(), dest));
+
+      dest.x() = safetyDistanceToMid;
+      dest.y() = dest.y() * std::min(ballWeightOtherHalf / -theFieldBall.recentBallEndPositionOnField().x() + safetyDistanceToMid, 1.f);
+      CROSS("Strategy:path3", dest.x(), dest.y(), 30, 3, Drawings::solidPen, ColorRGBA::red);
+      return SkillRequest::Builder::walkTo(Pose2f((theFieldBall.recentBallEndPositionOnField() - dest).angle(), dest));
+    }
+    case 2:
+      if((theFieldBall.timeSinceBallWasSeen > ballSearchDelay && !theFieldBall.teammatesBallIsValid) && theFrameInfo.getTimeSince(theGameState.timeWhenStateStarted) > ballStillOnSpot)
+        return searchBall();
+
+      timeBallSearchStarted = 0;
+      if((distanceToBall < 1500.f || ballWasNearMarked) && theFieldBall.ballWasSeen(timeToTrustBall) && theFieldBall.recentBallPositionOnField().x() < 0.f)
+      {
+        ballWasNearMarked = true;
+        return kickBall();
+      }
+
+      if(theFieldBall.recentBallPositionOnField().x() < 0)
+      {
+        //if the ball is in the own half we have to go towards it
+        return handleBallInOwnHalf();
+      }
+
+      Teammate number3;
+      for(const Teammate& t : theTeamData.teammates)
+      {
+        if(t.number == 3)
+        {
+          number3 = t;
+          break;
+        }
+      }
+      Vector2f positionOfTeammate = number3.theRobotPose.translation;
+
+      std::vector<Obstacle> obstaclesToMark;
+      std::vector<Obstacle> obstacles;
+      for(auto& o : theObstacleModel.obstacles)
+      {
+        Vector2f center = theRobotPose * o.center;
+        if(o.type != Obstacle::teammate && center.x() < notFirstAttacker && (center - positionOfTeammate).norm() > sameObstacleThreshold)
+          obstaclesToMark.push_back(o);
+      }
+
+      if(obstaclesToMark.empty())
+      {
+        //if the second attacker was already found he has walked outside of our field of view, so turn to find him again
+        if(secondAttackerFound)
+          return SkillRequest::Builder::walkTo(Pose2f(theRobotPose.rotation + (positionToMark.y() < theRobotPose.translation.y() ? -30_deg : 30_deg), theRobotPose.translation));
+        mirrored = theRobotPose.translation.y() > 0;
+        positionToMark = Vector2f(-600.f, mirrored ? 1700.f : -1700.f);
+        return SkillRequest::Builder::mark(positionToMark);
+      }
+
+      secondAttackerFound = true;
+      //mark the obstacle nearest to me
+      Obstacle newObstacleToMark = *std::min_element(obstaclesToMark.begin(), obstaclesToMark.end(), [&](Obstacle o1, Obstacle o2) {return o1.center.squaredNorm() < o2.center.squaredNorm(); });
+      CIRCLE("Strategy:mark2", positionToMark.x(), positionToMark.y(), sameObstacleThreshold + theFrameInfo.getTimeSince(timeWhenObstacleToMarkWasSeen) / 4, 20, Drawings::solidPen, ColorRGBA::violet, Drawings::noBrush, ColorRGBA::white);
+      if(timeWhenObstacleToMarkWasSeen == 0 || (theRobotPose * newObstacleToMark.center - positionToMark).norm() < sameObstacleThreshold + theFrameInfo.getTimeSince(timeWhenObstacleToMarkWasSeen) / 4)
+      {
+        positionToMark = theRobotPose * newObstacleToMark.center;
+        timeWhenObstacleToMarkWasSeen = newObstacleToMark.lastSeen;
+      }
+
+      if((positionToMark - theFieldBall.recentBallPositionOnField()).norm() < ballNearMarkedObstacle)
+        ballWasNearMarked = true;
+
+      if(theFrameInfo.getTimeSince(timeWhenObstacleToMarkWasSeen) > verifyOpponentToMarkTime)
+      {
+        if(theFrameInfo.getTimeSince(timeWhenObstacleToMarkWasSeen) > searchOpponentToMarkTime)
+          return SkillRequest::Builder::walkTo(
+              Pose2f(theRobotPose.rotation + (positionToMark.y() < theRobotPose.translation.y() ? -30_deg : 30_deg), theRobotPose.translation));
+        return SkillRequest::Builder::observe(positionToMark);
+      }
+
+      CROSS("Strategy:mark2", positionToMark.x(), positionToMark.y(), 50, 10, Drawings::solidPen, ColorRGBA::violet);
+
+      auto clippedPositionToMark = positionToMark;
+      if(positionToMark.x() > 0)
+        clippedPositionToMark.x() = 0;
+      return SkillRequest::Builder::mark(clippedPositionToMark);
+  }
+  return SkillRequest::Builder::empty();
+}
+
+SkillRequest StrategyBehaviorControlDBHDefender::kickBall()
+{
+  const Angle newAngleToBall = (theFieldBall.recentBallPositionOnField() - theRobotPose.translation).angle();
+  // no angle adjustments that are minor or close to the ball
+  float distanceToBall = theFieldBall.recentBallEndPositionRelative().norm();
+  if(distanceToBall > 150.f && std::abs(Angle::normalize(angleToBall - newAngleToBall)) > 10_deg)
+    angleToBall = newAngleToBall;
+  return SkillRequest::Builder::dribbleTo(angleToBall);
+}
+
+SkillRequest StrategyBehaviorControlDBHDefender::searchBall()
+{
+  if(timeBallSearchStarted == 0)
+    timeBallSearchStarted = theFrameInfo.time;
+
+  if(theFrameInfo.getTimeSince(timeBallSearchStarted) < ballSearchDuration)
+  {
+    if(theGameState.playerNumber == 2 ? theFieldBall.recentBallPositionOnField().x() < 0 : theFieldBall.recentBallPositionOnField().x() > 0)
+      return SkillRequest::Builder::observe(theFieldBall.recentBallPositionOnField());
+  }
+
+  switch(theGameState.playerNumber)
+  {
+    case 3:
+      if((theFrameInfo.getTimeSince(timeBallSearchStarted) + ballSearchDuration) % (3 * ballSearchDuration) < ballSearchDuration)
+        return SkillRequest::Builder::walkTo(Pose2f((Vector2f(theFieldDimensions.xPosOpponentPenaltyMark, 0.f) - theRobotPose.translation).angle(), theRobotPose.translation));
+      else if((theFrameInfo.getTimeSince(timeBallSearchStarted) + ballSearchDuration) % (3 * ballSearchDuration) < 2 * ballSearchDuration)
+        return SkillRequest::Builder::walkTo(Pose2f((Vector2f(-300.f, theFieldBall.recentBallPositionOnField().y() > 0 ? 1700.f : -1700.f) - theRobotPose.translation).angle(), theRobotPose.translation));
+      else
+        return SkillRequest::Builder::walkTo(Pose2f((Vector2f(-300.f, theFieldBall.recentBallPositionOnField().y() < 0 ? 1700.f : -1700.f) - theRobotPose.translation).angle(), theRobotPose.translation));
+      break;
+    case 2:
+      return SkillRequest::Builder::walkTo(Pose2f(theRobotPose.rotation + 20_deg, theRobotPose.translation));
+      break;
+    default:
+      return SkillRequest::Builder::empty();
+  }
+}
+
+SkillRequest StrategyBehaviorControlDBHDefender::handleBallInOwnHalf()
+{
+  if(theFieldBall.ballWasSeen(timeToTrustBall))
+  {
+    Vector2f pointToMark = positionToMark + (Vector2f(theFieldDimensions.xPosOwnGroundLine, 0) - positionToMark).normalized() * 500.f;
+
+    Geometry::Line line(pointToMark, theFieldBall.recentBallPositionOnField() - pointToMark);
+    Vector2f pointOnLine = Geometry::getOrthogonalProjectionOfPointOnLine(line, theRobotPose.translation);
+    Vector2f dest = pointOnLine + (theFieldBall.recentBallEndPositionOnField() - pointOnLine) *  ballWeight / (Geometry::distance(theRobotPose.translation, pointOnLine));
+    dest = Geometry::distance(dest, pointToMark) < Geometry::distance(theFieldBall.recentBallPositionOnField(), pointToMark) ? dest : theFieldBall.recentBallPositionOnField();
+    LINE("Strategy:mark2", pointToMark.x(), pointToMark.y(), theFieldBall.recentBallEndPositionOnField().x(), theFieldBall.recentBallEndPositionOnField().y(), 3, Drawings::dashedPen, ColorRGBA::red);
+    CROSS("Strategy:mark2", dest.x(), dest.y(), 30, 3, Drawings::solidPen, ColorRGBA::red);
+
+    return SkillRequest::Builder::walkTo(Pose2f((theFieldBall.recentBallEndPositionOnField() - dest).angle(), dest));
+  }
+  return SkillRequest::Builder::observe(theFieldBall.recentBallPositionOnField());
+}
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDefender.h b/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDefender.h
new file mode 100644
index 0000000000..7bf6737e3c
--- /dev/null
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDefender.h
@@ -0,0 +1,79 @@
+/**
+ * @file StrategyBehaviorControlDBHDefender.h
+ *
+ * This file declares a module that determines the strategy of the team.
+ *
+ * @author Yannik Meinken
+ * @author Lars Bredereke
+ */
+
+#pragma once
+
+#include "Representations/BehaviorControl/FieldBall.h"
+#include "Representations/BehaviorControl/SkillRequest.h"
+#include "Representations/Communication/TeamData.h"
+#include "Representations/Configuration/FieldDimensions.h"
+#include "Representations/Infrastructure/FrameInfo.h"
+#include "Representations/Infrastructure/GameState.h"
+#include "Representations/Modeling/ObstacleModel.h"
+#include "Representations/Modeling/RobotPose.h"
+#include "Framework/Module.h"
+#include "Math/Angle.h"
+
+MODULE(StrategyBehaviorControlDBHDefender,
+{,
+  REQUIRES(FieldDimensions),
+  REQUIRES(FrameInfo),
+  REQUIRES(GameState),
+  REQUIRES(ObstacleModel),
+  REQUIRES(RobotPose),
+  REQUIRES(FieldBall),
+  REQUIRES(TeamData),
+  PROVIDES(SkillRequest),
+  DEFINES_PARAMETERS(
+  {,
+    (int)(10000) ballSearchDelay, /**< if the ball is this long not seen the ball search is activated*/
+    (int)(10000) ballSearchDuration, /**< duration of one phase of the search, after tis time next position is observed*/
+    (int)(20000) ballStillOnSpot, /**< if we have not jet seen the ball we assume in this time that it is still on the penalty mark*/
+    (float)(100.f) ballWeight, /**< shod the first defender go straiter to the ball (higher) or more in the line of a potential pass (lower)*/
+    (float)(1000) notFirstAttacker, /**< obstacles with a x coordinate less than this are considered one of the pass receiving attackers*/
+    (int)(1000) timeToTrustBall, /**< if the ball was not seen this long we go not strait to it*/
+    (float)(300) safetyDistanceToMid,/**< distance the third defender always keeps to the middle line*/
+    (float)(300.f) ballWeightOtherHalf, /**< shod the first defender go straiter to the ball (higher) or more in the line of a potential pass (lower)*/
+    (int)(3000) verifyOpponentToMarkTime, /**< if the Opponent to mark was this long not seen look if he is still in the same spot*/
+    (int)(5000) searchOpponentToMarkTime, /**< if the Opponent to mark was this long not seen look to find him again*/
+    (float)(500.f) sameObstacleThreshold, /**< Threshold distance to update the lastObstaclToMark with the new one*/
+    (int)(3000) decideMirroredInterval, /**< in the first 3sec the 3 just walks forward and then decide based on the position of the 2 whether or not to play mirrored*/
+    (float)(1500.f) ballNearMarkedObstacle, /**< if the Ball was nearer then this to the obstacle that is marked always go directly to the ball*/
+  }),
+});
+
+class StrategyBehaviorControlDBHDefender : public StrategyBehaviorControlDBHDefenderBase
+{
+  /**
+   * Updates the skill request.
+   * @param skillRequest The provided skill request.
+   */
+  void update(SkillRequest& skillRequest) override;
+
+  SkillRequest behave();
+
+  SkillRequest kickBall();
+
+  SkillRequest searchBall();
+
+  SkillRequest handleBallInOwnHalf();
+
+  Angle angleToBall = 0.f;
+
+  bool secondAttackerFound = false;
+  bool ballFound = false;
+
+  bool mirrored = false;
+
+  Vector2f positionToMark = Vector2f(-600.f, mirrored ? 1700.f : -1700.f);
+  int timeWhenObstacleToMarkWasSeen = 0;
+  bool ballWasNearMarked = false;
+
+  int timeBallSearchStarted = 0; //How long since we startet searching the ball?
+};
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDortmund.cpp b/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDortmund.cpp
new file mode 100644
index 0000000000..72d6cd1275
--- /dev/null
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDortmund.cpp
@@ -0,0 +1,71 @@
+/**
+ * @file StrategyBehaviorControlDBHDefender.cpp
+ *
+ * This file implements a module that determines the strategy of the team.
+ *
+ * @author Yannik Meinken
+ */
+
+#include "StrategyBehaviorControlDBHDortmund.h"
+
+MAKE_MODULE(StrategyBehaviorControlDBHDortmund);
+
+void StrategyBehaviorControlDBHDortmund::update(SkillRequest& skillRequest)
+{
+  if(theGameState.playerState != GameState::active ||
+     theGameState.isPenaltyShootout() || theGameState.isInitial() || theGameState.isReady() || theGameState.isFinished())
+    skillRequest = SkillRequest::Builder::empty();
+  else if(theGameState.isSet())
+    skillRequest = SkillRequest::Builder::stand();
+  else if(theGameState.isPlaying())
+    skillRequest = behave();
+}
+
+SkillRequest StrategyBehaviorControlDBHDortmund::behave()
+{
+  switch(theGameState.playerNumber)
+  {
+    case 1:
+      if(theFieldBall.ballWasSeen(300) &&
+         theFieldBall.isRollingTowardsOwnGoal &&
+         theFieldBall.positionRelative.squaredNorm() < sqr(3000.f))
+      {
+        const float interceptY = clip(theFieldBall.intersectionPositionWithOwnYAxis.y(), theFieldDimensions.yPosRightGoal + 150.f, theFieldDimensions.yPosLeftGoal - 150.f);
+        return SkillRequest::Builder::walkTo(Pose2f(theFieldDimensions.xPosOwnGroundLine, interceptY));
+      }
+      if(theFieldBall.ballWasSeen(5000))
+      {
+        float positionY = mapToRange(theFieldBall.recentBallPositionOnField().y(), theFieldDimensions.yPosRightSideline, theFieldDimensions.yPosLeftSideline, theFieldDimensions.yPosRightGoal + 150.f, theFieldDimensions.yPosLeftGoal - 150.f);
+        positionY /= (theFieldBall.positionRelative.norm() / 2000.f);
+        return SkillRequest::Builder::walkTo(Pose2f(theFieldDimensions.xPosOwnGroundLine, positionY));
+      }
+      return SkillRequest::Builder::walkTo(Pose2f(theFieldDimensions.xPosOwnGroundLine, 0.f));
+    case 3:
+      if(theFieldBall.recentBallPositionOnField().x() > 0.f)
+        return kickBall();
+
+      return SkillRequest::Builder::stand();
+
+    case 2:
+      if(theFieldBall.recentBallPositionOnField().x() < 0)
+        return kickBall();
+
+      const Geometry::Line ballToGoal = Geometry::Line(theFieldBall.recentBallPositionOnField(), Vector2f(theFieldDimensions.xPosOwnGoal, 0) - theFieldBall.recentBallPositionOnField());
+      const Geometry::Line line = Geometry::Line(Vector2f(-2000, 0), Vector2f(0, 1));
+
+      Vector2f pos = Vector2f::Zero();
+      if(Geometry::getIntersectionOfLines(ballToGoal, line, pos))
+        return SkillRequest::Builder::walkTo(Pose2f((theFieldBall.recentBallPositionOnField() - pos).angle(), pos));
+  }
+  return SkillRequest::Builder::empty();
+}
+
+SkillRequest StrategyBehaviorControlDBHDortmund::kickBall()
+{
+  const Angle newAngleToBall = (theFieldBall.recentBallPositionOnField() - theRobotPose.translation).angle();
+  // no angle adjustments that are minor or close to the ball
+  float distanceToBall = theFieldBall.recentBallEndPositionRelative().norm();
+  if(distanceToBall > 150.f && std::abs(Angle::normalize(angleToBall - newAngleToBall)) > 10_deg)
+    angleToBall = newAngleToBall;
+  return SkillRequest::Builder::dribbleTo(angleToBall);
+}
diff --git a/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDortmund.h b/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDortmund.h
new file mode 100644
index 0000000000..2193697427
--- /dev/null
+++ b/Src/Modules/BehaviorControl/StrategyBehaviorControl/StrategyBehaviorControlDBHDortmund.h
@@ -0,0 +1,44 @@
+/**
+ * @file StrategyBehaviorControlDBHDefender.h
+ *
+ * This file declares a module that determines the strategy of the team.
+ *
+ * @author Yannik Meinken
+ */
+
+#pragma once
+
+#include "Representations/BehaviorControl/FieldBall.h"
+#include "Representations/BehaviorControl/SkillRequest.h"
+#include "Representations/Configuration/FieldDimensions.h"
+#include "Representations/Infrastructure/GameState.h"
+#include "Representations/Modeling/RobotPose.h"
+#include "Framework/Module.h"
+#include "Math/Angle.h"
+
+MODULE(StrategyBehaviorControlDBHDortmund,
+{,
+  REQUIRES(FieldDimensions),
+  REQUIRES(GameState),
+  REQUIRES(RobotPose),
+  REQUIRES(FieldBall),
+  PROVIDES(SkillRequest),
+  DEFINES_PARAMETERS(
+  {,
+  }),
+});
+
+class StrategyBehaviorControlDBHDortmund : public StrategyBehaviorControlDBHDortmundBase
+{
+  /**
+   * Updates the skill request.
+   * @param skillRequest The provided skill request.
+   */
+  void update(SkillRequest& skillRequest) override;
+
+  SkillRequest behave();
+
+  SkillRequest kickBall();
+
+  Angle angleToBall = 0.f;
+};
diff --git a/Src/Modules/Communication/TeamDataProvider/TeamDataProvider.cpp b/Src/Modules/Communication/TeamDataProvider/TeamDataProvider.cpp
index d5a6168fdf..244300c347 100644
--- a/Src/Modules/Communication/TeamDataProvider/TeamDataProvider.cpp
+++ b/Src/Modules/Communication/TeamDataProvider/TeamDataProvider.cpp
@@ -46,6 +46,7 @@ void TeamDataProvider::handleMessage(Teammate& teammate, const ReceivedTeamMessa
   teammate.theRobotPose = teamMessage.theRobotPose;
   teammate.theBallModel = teamMessage.theBallModel;
   teammate.theFrameInfo = teamMessage.theFrameInfo;
+  teammate.theObstacleModel = teamMessage.theObstacleModel;
   teammate.theBehaviorStatus = teamMessage.theBehaviorStatus;
   teammate.theWhistle = teamMessage.theWhistle;
   teammate.theStrategyStatus = teamMessage.theStrategyStatus;
diff --git a/Src/Modules/Communication/TeamMessageHandler/TeamMessageHandler.cpp b/Src/Modules/Communication/TeamMessageHandler/TeamMessageHandler.cpp
index 889674122e..c8fdffe6f4 100644
--- a/Src/Modules/Communication/TeamMessageHandler/TeamMessageHandler.cpp
+++ b/Src/Modules/Communication/TeamMessageHandler/TeamMessageHandler.cpp
@@ -30,6 +30,7 @@ MAKE_MODULE(TeamMessageHandler);
 #define FOREACH_TEAM_MESSAGE_REPRESENTATION(_) \
   _(RobotStatus); \
   _(FrameInfo); \
+  _(ObstacleModel); \
   _(BallModel); \
   _(Whistle); \
   _(BehaviorStatus); \
@@ -85,7 +86,7 @@ void TeamMessageHandler::update(BHumanMessageOutputGenerator& outputGenerator)
     return (notInPlayDead() &&
             !theGameState.isPenaltyShootout() &&
             !theGameState.isPenalized() &&
-            ((alwaysSend && enoughTimePassed()) ||
+            ((alwaysSend && enoughTimePassed() && theGameState.isPlaying()) ||
              ((theGameState.isReady() || theGameState.isSet() || theGameState.isPlaying()) && withinPriorityBudget() && whistleDetected()) ||
              (enoughTimePassed() && theGameState.isPlaying() && robotPoseValid() && withinNormalBudget() &&
               (behaviorStatusChanged() || robotStatusChanged() || strategyStatusChanged() || robotPoseChanged() || ballModelChanged() || teamBallOld()))));
@@ -158,6 +159,7 @@ bool TeamMessageHandler::writeMessage(BHumanMessageOutputGenerator& outputGenera
     COUNT(RobotStatus.isUpright);
     // COUNT(BehaviorStatus.calibrationFinished);
     COUNT(BehaviorStatus.passTarget);
+    COUNT(BehaviorStatus.lastKickTimestamp);
     statistics.count("BehaviorStatus.shootingTo",
                      globalBearingsChanged(theRobotPose, theBehaviorStatus.shootingTo,
                                            lastSent.theRobotPose, lastSent.theBehaviorStatus.shootingTo));
@@ -339,7 +341,8 @@ bool TeamMessageHandler::notInPlayDead() const
 bool TeamMessageHandler::withinNormalBudget() const
 {
   const int timeRemainingInCurrentHalf = std::max(0, -theFrameInfo.getTimeSince(theGameState.timeWhenPhaseEnds));
-  const int timeInNextHalf = theGameState.phase == GameState::firstHalf ? durationOfHalf : 0;
+  // This is a hack for the Dynamic Ball Handling Challenge where there is no second half, because only one run of 240 s is played.
+  const int timeInNextHalf = 0; // theGameState.phase == GameState::firstHalf ? durationOfHalf : 0;
   const int remainingTime = std::max(0, timeRemainingInCurrentHalf - lookahead) + timeInNextHalf;
   return (static_cast<int>(theGameState.ownTeam.messageBudget - normalMessageReserve) * durationOfHalf * 2 >
           static_cast<int>(overallMessageBudget - normalMessageReserve) * remainingTime);
@@ -362,6 +365,7 @@ bool TeamMessageHandler::behaviorStatusChanged() const
 {
   return (// theBehaviorStatus.calibrationFinished != lastSent.theBehaviorStatus.calibrationFinished || // not used
           theBehaviorStatus.passTarget != lastSent.theBehaviorStatus.passTarget ||
+          theBehaviorStatus.lastKickTimestamp != lastSent.theBehaviorStatus.lastKickTimestamp ||
           // theBehaviorStatus.walkingTo != lastSent.behaviorStatus.walkingTo || // included in robotPoseChanged
           // theBehaviorStatus.speed != lastSent.behaviorStatus.speed || // included in robotPoseChanged
           globalBearingsChanged(theRobotPose, theBehaviorStatus.shootingTo, lastSent.theRobotPose, lastSent.theBehaviorStatus.shootingTo));
diff --git a/Src/Modules/Communication/TeamMessageHandler/TeamMessageHandler.h b/Src/Modules/Communication/TeamMessageHandler/TeamMessageHandler.h
index 0f2037d977..c564b715ef 100644
--- a/Src/Modules/Communication/TeamMessageHandler/TeamMessageHandler.h
+++ b/Src/Modules/Communication/TeamMessageHandler/TeamMessageHandler.h
@@ -21,6 +21,7 @@
 #include "Representations/Configuration/BallSpecification.h"
 #include "Representations/Infrastructure/GameState.h"
 #include "Representations/Infrastructure/RobotHealth.h"
+#include "Representations/Modeling/ObstacleModel.h"
 #include "Representations/Modeling/TeammatesBallModel.h"
 #include "Representations/MotionControl/MotionInfo.h"
 #include "Representations/MotionControl/MotionRequest.h"
@@ -50,6 +51,7 @@ MODULE(TeamMessageHandler,
   // send directly
   USES(BallModel),
   USES(BehaviorStatus),
+  USES(ObstacleModel),
   USES(RobotPose),
   USES(StrategyStatus),
   USES(Whistle),
diff --git a/Src/Modules/Configuration/SetupPosesProvider/SetupPosesProvider.cpp b/Src/Modules/Configuration/SetupPosesProvider/SetupPosesProvider.cpp
index cd373fe133..89fb9a7c8e 100644
--- a/Src/Modules/Configuration/SetupPosesProvider/SetupPosesProvider.cpp
+++ b/Src/Modules/Configuration/SetupPosesProvider/SetupPosesProvider.cpp
@@ -35,9 +35,99 @@
  */
 
 #include "SetupPosesProvider.h"
+#include "Math/Random.h"
 
 SetupPosesProvider::SetupPosesProvider()
 {
+  const float minDistToLine = 150.f;
+  const float minOffset = 250.f;
+  // Note: This code should only be used for the Dynamic Ball Handling Challenge.
+  if(Global::getSettings().scenario.starts_with("DynamicBallHandlingChallengeAttacker"))
+  {
+    // Randomize setup positions within the corresponding area as defined in the challenge rules.
+    for(auto& setupPose : poses)
+    {
+      switch(setupPose.playerNumber)
+      {
+        // Attacking goalkeeper
+        case 1:
+        {
+          const float maxY = theFieldDimensions.yPosLeftGoal - minOffset - minDistToLine;
+          const float newY = Random::uniform(-maxY, maxY);
+          setupPose.position = Vector2f(setupPose.position.x(), newY);
+          setupPose.turnedTowards = setupPose.position + Vector2f(minDistToLine, 0.f);
+          continue;
+        }
+        // Left attacker
+        case 2:
+        {
+          const float minY = theFieldDimensions.centerCircleRadius * 2.f;
+          const float maxY = theFieldDimensions.yPosLeftSideline - minOffset;
+          const float newY = Random::uniform(minY, maxY);
+          const float newX = Random::uniform(-theFieldDimensions.centerCircleRadius - minOffset,
+                                             -minDistToLine - minOffset);
+          setupPose.position = Vector2f(newX, newY);
+          setupPose.turnedTowards = setupPose.position + Vector2f(minDistToLine, 0.f);
+          continue;
+        }
+        // Right attacker
+        case 3:
+        {
+          const float minY = theFieldDimensions.centerCircleRadius * 2.f;
+          const float maxY = theFieldDimensions.yPosLeftSideline - minOffset;
+          const float newY = Random::uniform(minY, maxY);
+          const float newX = Random::uniform(-theFieldDimensions.centerCircleRadius - minOffset,
+                                             -minDistToLine - minOffset);
+          setupPose.position = Vector2f(newX, -newY);
+          setupPose.turnedTowards = setupPose.position + Vector2f(minDistToLine, 0.f);
+          continue;
+        }
+        default:
+          continue;
+      }
+    }
+  }
+  else if(Global::getSettings().scenario.starts_with("DynamicBallHandlingChallenge"))
+  {
+    // Randomize setup positions within the corresponding area as defined in the challenge rules.
+    for(auto& setupPose : poses)
+    {
+      switch(setupPose.playerNumber)
+      {
+        // Defending goalkeeper
+        case 1:
+        {
+          const float maxY = theFieldDimensions.yPosLeftGoal - minOffset - minDistToLine;
+          const float newY = Random::uniform(-maxY, maxY);
+          setupPose.position = Vector2f(setupPose.position.x(), newY);
+          setupPose.turnedTowards = setupPose.position + Vector2f(minDistToLine, 0.f);
+          continue;
+        }
+        // Second defender
+        case 2:
+        {
+          const float maxY = theFieldDimensions.yPosLeftPenaltyArea - minOffset - minDistToLine;
+          const float newY = Random::uniform(-maxY, maxY);
+          const float newX = setupPose.position.x() + Random::uniform(-minOffset, minOffset);
+          setupPose.position = Vector2f(newX, newY);
+          setupPose.turnedTowards = setupPose.position + Vector2f(minDistToLine, 0.f);
+          continue;
+        }
+        // First defender
+        case 3:
+        {
+          const float maxR = theFieldDimensions.centerCircleRadius - minDistToLine;
+          const float newR = Random::uniform(minOffset, maxR);
+          // Random direction of +-67.5°
+          const Angle newAlpha = Random::uniform(-pi_2 + pi_8, pi_2 - pi_8);
+          setupPose.position = Vector2f::polar(-newR, newAlpha);
+          setupPose.turnedTowards = setupPose.position + Vector2f(minDistToLine, 0.f);
+          continue;
+        }
+      }
+    }
+  }
+
   representationHasBeenInitialized = false;
   // We assume that the default configuration is valid
   for(int i = 1; i <= 7; i++)
@@ -56,7 +146,7 @@ void SetupPosesProvider::update(SetupPoses& setupPoses)
   {
     if(robotOrderFromGC.size() <= setupPoses.poses.size())
     {
-      for(std::vector<int>::size_type i = 0; i<robotOrderFromGC.size(); i++)
+      for(std::vector<int>::size_type i = 0; i < robotOrderFromGC.size(); i++)
         setupPoses.poses[i].playerNumber = robotOrderFromGC[i];
     }
   }
@@ -65,10 +155,10 @@ void SetupPosesProvider::update(SetupPoses& setupPoses)
 bool SetupPosesProvider::updateRobotOrder()
 {
   std::vector<int> currentRobotOrder;
-  for(unsigned long i=0; i<theGameState.ownTeam.playerStates.size(); i++)
+  for(unsigned long i = 0; i < theGameState.ownTeam.playerStates.size(); i++)
   {
     if(theGameState.ownTeam.playerStates[i] != GameState::substitute)
-      currentRobotOrder.push_back(static_cast<int>(i)+1);
+      currentRobotOrder.push_back(static_cast<int>(i) + 1);
   }
   if(currentRobotOrder != robotOrderFromGC)
   {
diff --git a/Src/Modules/Configuration/SetupPosesProvider/SetupPosesProvider.h b/Src/Modules/Configuration/SetupPosesProvider/SetupPosesProvider.h
index 9ea71d89e0..d2594decaa 100644
--- a/Src/Modules/Configuration/SetupPosesProvider/SetupPosesProvider.h
+++ b/Src/Modules/Configuration/SetupPosesProvider/SetupPosesProvider.h
@@ -39,10 +39,12 @@
 #include "Framework/Module.h"
 #include "Representations/Configuration/SetupPoses.h"
 #include "Representations/Infrastructure/GameState.h"
+#include "Representations/Configuration/FieldDimensions.h"
 
 MODULE(SetupPosesProvider,
 {,
   REQUIRES(GameState),
+  REQUIRES(FieldDimensions),
   PROVIDES(SetupPoses),
   LOADS_PARAMETERS(
   {,
diff --git a/Src/Modules/Infrastructure/GameStateProvider/GameStateProvider.cpp b/Src/Modules/Infrastructure/GameStateProvider/GameStateProvider.cpp
index 8351143156..28ae41ef12 100644
--- a/Src/Modules/Infrastructure/GameStateProvider/GameStateProvider.cpp
+++ b/Src/Modules/Infrastructure/GameStateProvider/GameStateProvider.cpp
@@ -238,10 +238,10 @@ void GameStateProvider::update(GameState& gameState)
           switch(gameState.state)
           {
             case GameState::waitForOwnKickOff:
-              gameState.state = GameState::ownKickOff;
+              gameState.state = GameState::playing;
               break;
             case GameState::waitForOpponentKickOff:
-              gameState.state = GameState::opponentKickOff;
+              gameState.state = GameState::playing;
               break;
             case GameState::waitForOwnPenaltyKick:
               gameState.state = GameState::ownPenaltyKick;
@@ -796,16 +796,7 @@ GameState::State GameStateProvider::convertGameControllerDataToState(const GameC
     else
     {
       ASSERT(gameControllerData.setPlay == SET_PLAY_NONE);
-      if(gameControllerData.secondaryTime > 0)
-      {
-        // The GameController doesn't explicitly have a state for this in the network messages,
-        // but a secondaryTime != 0 can only happen during kick-off. This only happens when the
-        // GameController's 15s delay after the whistle ends early due to an event that could
-        // not occur during SET.
-        return isKickingTeam ? GameState::ownKickOff : GameState::opponentKickOff;
-      }
-      else
-        return GameState::playing;
+      return GameState::playing;
     }
   }
   else if(gameControllerData.state == STATE_FINISHED)
diff --git a/Src/Modules/Modeling/SelfLocator/SelfLocator.cpp b/Src/Modules/Modeling/SelfLocator/SelfLocator.cpp
index 64067225b8..13897f7d56 100644
--- a/Src/Modules/Modeling/SelfLocator/SelfLocator.cpp
+++ b/Src/Modules/Modeling/SelfLocator/SelfLocator.cpp
@@ -585,7 +585,8 @@ void SelfLocator::handleGameStateChanges()
   // Normal game is about to start: We start on the sidelines looking at our goal: (this is for checking in TeamCom)
   else if((theGameState.isInitial() && !theExtendedGameState.wasInitial()) ||
           // Normal game really starts: We start on the sidelines looking at our goal: (this is for actual setup)
-          (theGameState.isReady() && theExtendedGameState.wasInitial()))
+          (theGameState.isReady() && theExtendedGameState.wasInitial()) ||
+          (theGameState.isSet() && !theExtendedGameState.wasSet() && Global::getSettings().scenario.starts_with("DynamicBallHandlingChallenge"))) // HACK for Dynamic Ball Handling Challenge Defender, which skips the READY phase
   {
     for(int i = 0; i < samples->size(); ++i)
       samples->at(i).init(getNewPoseAtWalkInPosition(), walkInPoseDeviation, nextSampleNumber++, 0.5f);
diff --git a/Src/Modules/MotionControl/WalkingEngine/WalkGenerators/WalkToBallAndKickEngine.cpp b/Src/Modules/MotionControl/WalkingEngine/WalkGenerators/WalkToBallAndKickEngine.cpp
index 4033c46b29..59b87a0d0f 100644
--- a/Src/Modules/MotionControl/WalkingEngine/WalkGenerators/WalkToBallAndKickEngine.cpp
+++ b/Src/Modules/MotionControl/WalkingEngine/WalkGenerators/WalkToBallAndKickEngine.cpp
@@ -125,6 +125,9 @@ void WalkToBallAndKickEngine::update(WalkToBallAndKickGenerator& walkToBallAndKi
     if(!(motionRequest.kickType == KickInfo::walkForwardStealBallLeft || motionRequest.kickType == KickInfo::walkForwardStealBallRight)) // we are so close to the ball. The velocity might be a false perception
       isInPositionForKick &= motionRequest.ballEstimate.velocity.norm() < maxBallVelocity;
 
+    if(motionRequest.alignPrecisely == KickPrecision::forceWait)
+      isInPositionForKick = false;
+
     if(isInPositionForKick)
     {
       auto kickPhase = createKickPhase(motionRequest, lastPhase, walkKickVariant);
diff --git a/Src/Representations/BehaviorControl/BehaviorStatus.h b/Src/Representations/BehaviorControl/BehaviorStatus.h
index fa79ac3c02..2ec9564a6e 100644
--- a/Src/Representations/BehaviorControl/BehaviorStatus.h
+++ b/Src/Representations/BehaviorControl/BehaviorStatus.h
@@ -22,4 +22,5 @@ STREAMABLE(BehaviorStatus, COMMA public BHumanCompressedMessageParticle<Behavior
   (Vector2f)(Vector2f::Zero()) walkingTo, /**< The target position the robot is walking to (in robot relative coordinates). */
   (float) speed, /**< The absolute speed in mm/s. */
   (std::optional<Vector2f>) shootingTo, /**< The target position the robot is kicking the ball to (in robot relative coordinates). */
+  (unsigned)(0) lastKickTimestamp, /**< The timestamp of the most recently finished kick. */
 });
diff --git a/Src/Representations/BehaviorControl/ExecutedPasses.h b/Src/Representations/BehaviorControl/ExecutedPasses.h
new file mode 100644
index 0000000000..dca1950b43
--- /dev/null
+++ b/Src/Representations/BehaviorControl/ExecutedPasses.h
@@ -0,0 +1,16 @@
+/**
+ * @file ExecutedPasses.h
+ *
+ * This file defines a representation that keeps track of the number of performed passes based on team communication.
+ *
+ * @author Jo Lienhoop
+ */
+
+#pragma once
+
+#include "Streaming/AutoStreamable.h"
+
+STREAMABLE(ExecutedPasses,
+{,
+  (unsigned)(0) number, /**< The number of perfomed performed based on team communication */
+});
diff --git a/Src/Representations/BehaviorControl/FieldRating.h b/Src/Representations/BehaviorControl/FieldRating.h
index edcd0a8178..6cef495460 100644
--- a/Src/Representations/BehaviorControl/FieldRating.h
+++ b/Src/Representations/BehaviorControl/FieldRating.h
@@ -28,7 +28,7 @@ STREAMABLE(PotentialValue,
 STREAMABLE(FieldRating,
 {
   FUNCTION(PotentialValue(const float x, const float y, const bool calculateFieldDirection)) potentialFieldOnly;
-  FUNCTION(void(PotentialValue& pv, const float x, const float y, bool& teammateArea, const bool calculateFieldDirection, const int passTarget)) potentialOverall;
+  FUNCTION(void(PotentialValue& pv, const float x, const float y, int& teammatePass, const bool calculateFieldDirection, const int passTarget)) potentialOverall;
   FUNCTION(void(PotentialValue& pv, const PotentialValue& ballNear)) removeBallNearFromTeammatePotential;
   FUNCTION(void(PotentialValue& pv, const float x, const float y, const bool calculateFieldDirection)) duelBallNearPotential;
   FUNCTION(void(PotentialValue& pv, const float x, const float y, const bool calculateFieldDirection)) getObstaclePotential;
diff --git a/Src/Representations/BehaviorControl/PassEvaluation.h b/Src/Representations/BehaviorControl/PassEvaluation.h
index 6d93e0841c..6c419e9e58 100644
--- a/Src/Representations/BehaviorControl/PassEvaluation.h
+++ b/Src/Representations/BehaviorControl/PassEvaluation.h
@@ -13,5 +13,5 @@
 
 STREAMABLE(PassEvaluation,
 {
-  FUNCTION(float(const Vector2f& pointOnField)) getRating, /**< Estimates the probability that a pass from the current ball position to the given target position would be successful, taking into account the known obstacles. */
+  FUNCTION(float(const Vector2f& baseOnField, const Vector2f& targetOnField)) getRating, /**< Estimates the probability that a pass from the base position (e.g. current position) to the given target position would be successful, taking into account the known obstacles. */
 });
diff --git a/Src/Representations/Communication/ReceivedTeamMessages.h b/Src/Representations/Communication/ReceivedTeamMessages.h
index 076ad9d237..202868d816 100644
--- a/Src/Representations/Communication/ReceivedTeamMessages.h
+++ b/Src/Representations/Communication/ReceivedTeamMessages.h
@@ -11,6 +11,7 @@
 #include "Representations/BehaviorControl/BehaviorStatus.h"
 #include "Representations/BehaviorControl/StrategyStatus.h"
 #include "Representations/Infrastructure/FrameInfo.h"
+#include "Representations/Modeling/ObstacleModel.h"
 #include "Representations/Modeling/RobotPose.h"
 #include "Representations/Modeling/Whistle.h"
 #include "Tools/Communication/RobotStatus.h"
@@ -25,6 +26,7 @@ STREAMABLE(ReceivedTeamMessage,
   (RobotPose) theRobotPose,
   (BallModel) theBallModel,
   (FrameInfo) theFrameInfo,
+  (ObstacleModel) theObstacleModel,
   (BehaviorStatus) theBehaviorStatus,
   (Whistle) theWhistle,
   (StrategyStatus) theStrategyStatus,
diff --git a/Src/Representations/Communication/SentTeamMessage.h b/Src/Representations/Communication/SentTeamMessage.h
index e2af5eb9e2..76ab47bcdb 100644
--- a/Src/Representations/Communication/SentTeamMessage.h
+++ b/Src/Representations/Communication/SentTeamMessage.h
@@ -14,6 +14,7 @@
 #include "Representations/BehaviorControl/BehaviorStatus.h"
 #include "Representations/BehaviorControl/StrategyStatus.h"
 #include "Representations/Infrastructure/FrameInfo.h"
+#include "Representations/Modeling/ObstacleModel.h"
 #include "Representations/Modeling/RobotPose.h"
 #include "Representations/Modeling/Whistle.h"
 #include "Tools/Communication/RobotStatus.h"
@@ -23,6 +24,7 @@ STREAMABLE(SentTeamMessage,
   (BallModel) theBallModel,
   (BehaviorStatus) theBehaviorStatus,
   (FrameInfo) theFrameInfo,
+  (ObstacleModel) theObstacleModel,
   (RobotPose) theRobotPose,
   (RobotStatus) theRobotStatus,
   (StrategyStatus) theStrategyStatus,
diff --git a/Src/Representations/Communication/TeamData.h b/Src/Representations/Communication/TeamData.h
index 4bd0b54d38..509bf9310c 100644
--- a/Src/Representations/Communication/TeamData.h
+++ b/Src/Representations/Communication/TeamData.h
@@ -13,6 +13,7 @@
 #include "Representations/BehaviorControl/BehaviorStatus.h"
 #include "Representations/BehaviorControl/StrategyStatus.h"
 #include "Representations/Infrastructure/FrameInfo.h"
+#include "Representations/Modeling/ObstacleModel.h"
 #include "Representations/Modeling/RobotPose.h"
 #include "Representations/Modeling/Whistle.h"
 #include "Tools/Communication/RobotStatus.h"
@@ -32,6 +33,7 @@ STREAMABLE(Teammate,
   (RobotPose) theRobotPose,
   (BallModel) theBallModel,
   (FrameInfo) theFrameInfo,
+  (ObstacleModel) theObstacleModel,
   (BehaviorStatus) theBehaviorStatus,
   (Whistle) theWhistle,
   (StrategyStatus) theStrategyStatus,
diff --git a/Src/Representations/Modeling/ObstacleModel.cpp b/Src/Representations/Modeling/ObstacleModel.cpp
index 15f5df7634..99ad8778c6 100644
--- a/Src/Representations/Modeling/ObstacleModel.cpp
+++ b/Src/Representations/Modeling/ObstacleModel.cpp
@@ -8,6 +8,21 @@
 #include "Tools/Modeling/Obstacle.h"
 #include "Framework/Blackboard.h"
 
+void ObstacleModel::operator>>(BHumanMessage& m) const
+{
+  std::sort(const_cast<std::vector<Obstacle>&>(obstacles).begin(),
+            const_cast<std::vector<Obstacle>&>(obstacles).end(),
+            [](const Obstacle& a,
+               const Obstacle& b){ return a.center.squaredNorm() < b.center.squaredNorm(); });
+
+  Streaming::streamIt(*m.out, "theObstacleModel", *this);
+}
+
+void ObstacleModel::operator<<(const BHumanMessage& m)
+{
+  Streaming::streamIt(*m.in, "theObstacleModel",  *this);
+}
+
 void ObstacleModel::verify() const
 {
   DECLARE_DEBUG_RESPONSE("representation:ObstacleModel:verify");
diff --git a/Src/Representations/Modeling/ObstacleModel.h b/Src/Representations/Modeling/ObstacleModel.h
index f11e08d4b7..ab29155b53 100644
--- a/Src/Representations/Modeling/ObstacleModel.h
+++ b/Src/Representations/Modeling/ObstacleModel.h
@@ -7,8 +7,9 @@
  */
 #pragma once
 
-#include "Math/Eigen.h"
+#include "Tools/Communication/BHumanMessageParticle.h"
 #include "Streaming/Enum.h"
+#include "Math/Eigen.h"
 #include "Tools/Modeling/Obstacle.h"
 
 /**
@@ -18,8 +19,12 @@
  * foot bumper contact.
  */
 
-STREAMABLE(ObstacleModel,
+STREAMABLE(ObstacleModel, COMMA public BHumanMessageParticle
 {
+  /** BHumanMessageParticle functions */
+  void operator>>(BHumanMessage& m) const override;
+  void operator<<(const BHumanMessage& m) override;
+
   ObstacleModel() = default;
   void draw() const;
   void verify() const,
diff --git a/Src/Representations/MotionControl/MotionRequest.cpp b/Src/Representations/MotionControl/MotionRequest.cpp
index baeacaaa9d..04a05ef109 100644
--- a/Src/Representations/MotionControl/MotionRequest.cpp
+++ b/Src/Representations/MotionControl/MotionRequest.cpp
@@ -71,11 +71,12 @@ void MotionRequest::draw() const
     if((motion == MotionRequest::walkToBallAndKick || motion == MotionRequest::dribble) &&
        Blackboard::getInstance().exists("FieldBall") && Blackboard::getInstance().exists("RobotPose"))
     {
+      const float useKickLength = std::min(10000.f, kickLength);
       const FieldBall& theFieldBall = static_cast<FieldBall&>(Blackboard::getInstance()["FieldBall"]);
       const RobotPose& theRobotPose = static_cast<RobotPose&>(Blackboard::getInstance()["RobotPose"]);
-      const Vector2f ballTarget = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(kickLength, targetDirection + theRobotPose.rotation);
-      const Vector2f ballTargetMin = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(kickLength, targetDirection + theRobotPose.rotation + directionPrecision.min);
-      const Vector2f ballTargetMax = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(kickLength, targetDirection + theRobotPose.rotation + directionPrecision.max);
+      const Vector2f ballTarget = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(useKickLength, targetDirection + theRobotPose.rotation);
+      const Vector2f ballTargetMin = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(useKickLength, targetDirection + theRobotPose.rotation + directionPrecision.min);
+      const Vector2f ballTargetMax = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(useKickLength, targetDirection + theRobotPose.rotation + directionPrecision.max);
       LINE3D("representation:MotionRequest:kickDirection", theFieldBall.interceptedEndPositionOnField.x(), theFieldBall.interceptedEndPositionOnField.y(), 0, ballTargetMin.x(), ballTargetMin.y(), 0,
              5, ColorRGBA::blue);
       LINE3D("representation:MotionRequest:kickDirection", theFieldBall.interceptedEndPositionOnField.x(), theFieldBall.interceptedEndPositionOnField.y(), 0, ballTargetMax.x(), ballTargetMax.y(), 0,
@@ -93,11 +94,12 @@ void MotionRequest::draw() const
     if((motion == MotionRequest::walkToBallAndKick || motion == MotionRequest::dribble) &&
        Blackboard::getInstance().exists("FieldBall") && Blackboard::getInstance().exists("RobotPose"))
     {
+      const float useKickLength = std::min(10000.f, kickLength);
       const FieldBall& theFieldBall = static_cast<FieldBall&>(Blackboard::getInstance()["FieldBall"]);
       const RobotPose& theRobotPose = static_cast<RobotPose&>(Blackboard::getInstance()["RobotPose"]);
-      const Vector2f ballTarget = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(kickLength, targetDirection + theRobotPose.rotation);
-      const Vector2f ballTargetMin = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(kickLength, targetDirection + theRobotPose.rotation + directionPrecision.min);
-      const Vector2f ballTargetMax = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(kickLength, targetDirection + theRobotPose.rotation + directionPrecision.max);
+      const Vector2f ballTarget = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(useKickLength, targetDirection + theRobotPose.rotation);
+      const Vector2f ballTargetMin = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(useKickLength, targetDirection + theRobotPose.rotation + directionPrecision.min);
+      const Vector2f ballTargetMax = theFieldBall.interceptedEndPositionOnField + Vector2f::polar(useKickLength, targetDirection + theRobotPose.rotation + directionPrecision.max);
       LINE("representation:MotionRequest:kickDirection", theFieldBall.interceptedEndPositionOnField.x(), theFieldBall.interceptedEndPositionOnField.y(), ballTargetMin.x(), ballTargetMin.y(),
            5, Drawings::solidPen, ColorRGBA::blue);
       LINE("representation:MotionRequest:kickDirection", theFieldBall.interceptedEndPositionOnField.x(), theFieldBall.interceptedEndPositionOnField.y(), ballTargetMax.x(), ballTargetMax.y(),
diff --git a/Src/Tools/BehaviorControl/KickSelection.h b/Src/Tools/BehaviorControl/KickSelection.h
index fd889fd2bd..da430aa7de 100644
--- a/Src/Tools/BehaviorControl/KickSelection.h
+++ b/Src/Tools/BehaviorControl/KickSelection.h
@@ -98,7 +98,7 @@ namespace KickSelection
    * @author Jo Lienhoop
    * @author Yannik Meinken
    */
-  inline Angle calculateTargetRotation(const Vector2f& ballPosition, const Vector2f& receiverPosition, const Vector2f& goalPosition, Angle maxVisionAngle = 60_deg, const float magicalFactor = 0.5f)
+  inline Angle calculateTargetRotation(const Vector2f& ballPosition, const Vector2f& receiverPosition, const Vector2f& goalPosition, Angle maxVisionAngle = 60_deg, const float magicalFactor = 0.2f)
   {
     Angle receiverToGoal = (goalPosition - receiverPosition).angle();
     Angle receiverToBall = (ballPosition - receiverPosition).angle();
diff --git a/Src/Tools/BehaviorControl/Strategy/BehaviorBase.h b/Src/Tools/BehaviorControl/Strategy/BehaviorBase.h
index 2a6e541ac0..c86bdcf5c6 100644
--- a/Src/Tools/BehaviorControl/Strategy/BehaviorBase.h
+++ b/Src/Tools/BehaviorControl/Strategy/BehaviorBase.h
@@ -11,6 +11,7 @@
 
 #include "Representations/BehaviorControl/BallSearchAreas.h"
 #include "Representations/BehaviorControl/ExpectedGoals.h"
+#include "Representations/BehaviorControl/ExecutedPasses.h"
 #include "Representations/BehaviorControl/FieldBall.h"
 #include "Representations/BehaviorControl/GoaliePose.h"
 #include "Representations/BehaviorControl/Libraries/LibPosition.h"
@@ -34,6 +35,7 @@
   _(BallSpecification) \
   _(BehaviorParameters) \
   _(ExpectedGoals) \
+  _(ExecutedPasses) \
   _(FieldBall) \
   _(FieldDimensions) \
   _(FrameInfo) \
diff --git a/Src/Tools/BehaviorControl/Strategy/Strategy.h b/Src/Tools/BehaviorControl/Strategy/Strategy.h
index c353a462cb..2ac45f3dba 100644
--- a/Src/Tools/BehaviorControl/Strategy/Strategy.h
+++ b/Src/Tools/BehaviorControl/Strategy/Strategy.h
@@ -23,6 +23,7 @@ STREAMABLE(Strategy,
   {,
     none,
     s7v7,
+    dbhc,
   });
 
   template<typename SetPlayType>
diff --git a/Src/Tools/BehaviorControl/Strategy/Tactic.h b/Src/Tools/BehaviorControl/Strategy/Tactic.h
index ed542059ab..e1a1596db3 100644
--- a/Src/Tools/BehaviorControl/Strategy/Tactic.h
+++ b/Src/Tools/BehaviorControl/Strategy/Tactic.h
@@ -21,6 +21,7 @@ STREAMABLE(Tactic,
     none,
     t123,
     t222,
+    t012,
   });
 
   STREAMABLE(Position,
diff --git a/Src/Tools/Motion/KickPrecision.h b/Src/Tools/Motion/KickPrecision.h
index 82da154ba9..d504e77947 100644
--- a/Src/Tools/Motion/KickPrecision.h
+++ b/Src/Tools/Motion/KickPrecision.h
@@ -10,6 +10,7 @@
 
 ENUM(KickPrecision,
 {,
+  forceWait, /**< Prevent the robot from executing the kick. */
   precise, /**< As precise as the kick can get. */
   notPrecise, /**< Some inaccuracy is allowed. */
   justHitTheBall, /**< Throw all precision out of the window and just touch the ball. */
-- 
2.37.5

